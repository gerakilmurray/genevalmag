\chapter{Introducci\'on}
\label{chap:intro}
\minitoc

En las ciencias de la computación los lenguajes juegan un rol muy importante en muchas disciplinas. Desde los comienzos se buscaron mecanismos para describirlos y manejarlos, esta rama de la informática ha logrado muchos avances en el tema.

Dentro de los mecanismos desarrollados, las gramáticas han logrado ocupar unos de los lugares más destacados. La continua evolución y descubrimientos de nuevas gramáticas necesitó que se organizaran, y no fue hasta 1956 que Noam Chomsky propuso una jerarquía sobre las gramáticas.

Las clasificó en 4 niveles:

\begin{figure}[h!]\centering 
\begin{tabular}{| c | p{3.5cm} | p{4cm} | p{3cm} |}
\hline

\rowcolor{gris} \textbf{Tipo} & \textbf{Lenguaje} & \textbf{Autómata} & \textbf{Restricciones} \\ \hline

\multirow{2}{*}{\textbf{0}} & Recursivamente   & Máquina de  & \multirow{2}{*}{Sin restricciones} \\ 
                            & enumerable (LRE) & Turing (MT) & \\ \hline

\multirow{2}{*}{\textbf{1}} & Dependiente del & Autómata linealmente & \multirow{2}{*}{$\alpha A \beta \rightarrow \alpha\gamma\beta$} \\ 
                            & contexto (LSC)  & acotado              & \\ \hline

\multirow{2}{*}{\textbf{2}} & Independiente del & \multirow{2}{*}{Autómata con pila} & \multirow{2}{*}{$A \rightarrow \gamma$} \\ 
                            & contexto (LLC)    &                   & \\ \hline

\multirow{2}{*}{\textbf{3}} & \multirow{2}{*}{Regular (RL)} & \multirow{2}{*}{Autómata finito} & $A \rightarrow aB$ \\ 
                            &              &                 & $A \rightarrow a$ \\ \hline
\end{tabular}\caption{\label{chomsky} Jerarquía de Chomsky}
\end{figure}

Desde que D. Knuth introdujo en 1966 las gramáticas de atributos (GA), estas se han utilizado ampliamente para el desarrollo de herramientas de procesamiento de lenguajes formales como compiladores, intérpretes, traductores como también para especificar la semántica de lenguajes de programación.

En el desarrollo de este capítulo, introductorio, abordaremos un amplio numero de conceptos desde un punto de vista informal. A partir del capítulo 2 hasta el 4 inclusive se analizaran algunos de ellos, con mas formalidad y los siguientes capítulos estarán destinados al desarrollo de \maggen. 

\maggen\ es el objetivo principal del proyecto y su denominación esta dada por la combinación de las silabas \textbf{mag}, que significa \textit{multi-plans attribute grammar} y \textbf{Gen} por \textit{generator}. Estas dos silabas dan significado a \maggen\ como ``Generador de Evaluadores Estáticos para MAG''.

\section{Gramática libre de contexto}
En el nivel 2 de la jerarquía de chomsky \ref{chomsky} se encuentran los lenguajes libres de contexto. Las gramaticas libres de contexto son un formalismo que permite expresar cadenas de este tipo de lenguajes.

Las gramaticas libres de contexto han tomado gran importancia en la descripción de formatos de documentos\footnote{ DTD - document-type definition.}, como XML (extensible markup language) y también en tecnología de compilación, mediante la construcción de \textit{parser} de lenguajes.  
\begin{definition}
Una gramática libre de contexto se conforma de 4 componentes necesarios para la descripción de un lenguaje:
\begin{enumerate}
\item Un conjunto finito de símbolos que son los string que se definen el lenguaje. Este conjunto es denominado ``alfabeto de terminales'' o simplemente \textit{\textbf{símbolos terminales}}.

\item Un conjunto finito de variables llamados \textit{\textbf{símbolos no terminales}} o ``categorías sintácticas''.Cada uno de estos define un lenguaje, es decir un conjunto de strings.

\item Una variable que representa el comienzo del lenguaje, que se denomina \textit{\textbf{símbolo inicial}}. Dicha variable pertenece al conjunto del punto 2.

\item Un conjunto finito de \textit{\textbf{producciones o reglas}} que representan la definición recursiva de un lenguaje. Cada producción consiste de las siguientes partes:

\begin{enumerate}
\item Un símbolo no terminal perteneciente al conjunto del punto 2, denominado \textit{\textbf{head}} de la producción.

\item El símbolo \textbf{$\rightarrow$}.

\item Una secuencia de 0 o mas símbolos no terminales y terminales. Este, es denominado \textit{\textbf{body}} de la producción y representa el string formado por el \textit{head}.
\end{enumerate}

\end{enumerate}

Estos cuatro componentes pueden ser representados por una tupla \textbf{<V,T,S,P>}\ donde \textbf{V} es el conjunto de no terminales (punto 1), \textbf{T} el conjunto de terminales (punto 2), \textbf{S} es el símbolo inicial (punto 3) y \textbf{P} es el conjunto de producciones (punto 4).
\end{definition}
Veamos dos ejemplos desarrollados en \cite{gramatica} (capítulo 5):

\begin{enumerate}
\item Ejemplo: palíndromo:
Definimos la gramatica $G_{pal}$ para definir el lenguaje de palindromos\footnote{Un palíndromo (del griego palin dromein, volver a ir hacia atrás) es una palabra, número o frase que se lee igual hacia adelante que hacia atrás. Si se trata de un número, se llama capicúa (\urllink{http://es.wikipedia.org/wiki/Pal\%C3\%ADndromo}).}: \\
$G_{pal} = (\{P\},\{0,1\},P,A)$
donde A es el siguiente conjunto de producciones:
\begin{enumerate}
\item $P \rightarrow \lambda$
\item $P \rightarrow 0$
\item $P \rightarrow 1$
\item $P \rightarrow 0 P 0$
\item $P \rightarrow 1 P 1$
\end{enumerate}
Ejemplos de cadenas del lenguaje $G_{pal}$:
\begin{items}
\item $\lambda$
\item 0011
\item 11110000
\item etc.
\end{items}

\item Ejemplo: Gramatica de expresiones:\\
\textbf{G = (\{E,I\}, \{+,*,(,),a,b,0,1\}, E, P)} donde P es el conjunto de producciones siguiente:
\begin{enumerate}
\item $E \rightarrow I$
\item $E \rightarrow E + E$
\item $E \rightarrow E * E$
\item $E \rightarrow (E)$
\item $I \rightarrow a$
\item $I \rightarrow b$
\item $I \rightarrow Ia$
\item $I \rightarrow Ib$
\item $I \rightarrow I0$
\item $I \rightarrow I1$
\end{enumerate}
\begin{items}
\item a
\item b00
\item a*(a+b00)
\item etc.
\end{items}
\end{enumerate}

\underline{Notación}: Cuando denotamos una producción podemos utilizar una abreviación para agrupar aquellas producciones con el mismo \textit{head}. Para ello utilizamos el metasimbolo ``|''. Por ejemplo el conjunto de producciones de $G_{pal}$ podríamos escribirlas como: $P \rightarrow \lambda | 0 | 1 | 0P0 | 1P1$ 

\section{Gramática de Atributos (GA)}

Las gramáticas de atributos son un formalismo simple para la especificación de la semántica de lenguajes formales, como los lenguajes de programación o de especificación. Integran la modularidad que brindan las gramáticas libres de contexto y la expresividad de un lenguaje funcional.

En una gramática de atributos, se relaciona con cada símbolo de una gramática libre de contexto un conjunto de atributos. Cada regla o producción tiene asociados un conjunto de reglas semánticas que toman la forma de asignación a atributos de valores denotados por la aplicación de una función, la cual puede tomar como argumentos instancias de atributos pertenecientes a los símbolos que aparecen en la producción.
Las reglas semánticas inducen dependencias entre los atributos que ocurren en la producción. El orden de evaluación es implícito (si existe) y queda determinado por las dependencias entre las instancias de los atributos.
Una regla semántica se podrá evaluar cuando las instancias de los atributos que aparecen como sus argumentos estén evaluadas. 



\section{Árbol sintáctico atribuido}

Un árbol sintáctico abstracto (AST) es una forma condensada de un árbol de análisis sintáctico. Este es útil para representar construcciones de lenguajes.

Por ejemplo una producción de la forma:
\begin{center}\large
$S\ \rightarrow\ \textbf{if}\ B\ \textbf{then}\ S1\ \textbf{else}\ S2$                                                                      \end{center}
puede aparecer en un árbol sintáctico como:

\begin{figure}[h!]\centering
\includegraphics[width=125pt,height=53pt]{ast-ejemplo.pdf}
\caption{\label{ejem-ast} Ejemplo AST.}
\end{figure}


Un árbol sintáctico se compone de dos tipos de nodos:
\begin{description}
\item [Nodos hojas]
\item [Nodos interiores]
\end{description}

HABLAR UN POCO MAS DE PORQUE SE DENOMINA ATRIBUIDO.


\section{Métodos de Evaluación}

Un evaluador de gramáticas de atributos debe tener en cuenta las dependencias entre las instancias de atributos para seguir un orden consistente de evaluación de los mismos.

Si una GA contiene dependencias circulares no podría ser evaluada ya que no se encontraría un orden de evaluación. Esto se conoce como el problema de la circularidad, el cual se ha demostrado ser intrínsecamente exponencial\ref{XXX}. El problema de la circularidad ha motivado que muchos investigadores hayan realizado esfuerzos en la búsqueda e identificación de familias o subgrupos de gramáticas de atributos, para las cuales puedan detectarse circularidades con algoritmos de menor complejidad (polinomial o lineal).

Estas familias imponen restricciones sobre la gramática de atributos o sobre las dependencias entre sus atributos para garantizar que una GA no sea circular, con el costo de restringir su poder expresivo.

En 1980, Uwe Kastens\ref{XXX} caracterizó las gramáticas de atributos ordenadas y propuso un método para su evaluación, denominado secuencias de visita. Estas son, secuencias de operaciones que conducen el recorrido del árbol sintáctico atribuido y realizan la evaluación de las instancias de los atributos. Kastens propone un método para generar las secuencias de visita en tiempo polinomial para la familia OAG. Esta familia y otras como las absolutamente no circulares (ANCAG)\ref{XXX} son tratadas en el capítulo 2.

Luego, en 1998, Wuu-Yang en \cite{wuu-yang1} caracteriza una nueva familia denominada \textbf{Gramática de Atributos Multi-plans}, presentado una algoritmo de evaluación basado en secuencia de visita en tiempo polinomial en el numero de símbolos y producciones. Estas, son desarrolladas en el capítulo 3 y son en las que se basa el funcionamientos de \maggen.  

\subsection{Evaluación dinámica}

Un evaluador dinámico tiene como ventajas su simplicidad y que es posible evaluar cualquier WDAG (GA bien definida) o aún GA’s irrestrictas utilizando \textit{evaluación lazy}\footnote{\urllink{http://en.wikipedia.org/wiki/Lazy\_evaluation}} (siempre y cuando exista el mínimo punto fijo en el álgebra de términos denotado por las ecuaciones de atribución). Además se pueden detectar ciclos en el grafo de dependencias antes o durante la evaluación.

Las principales desventajas son que generalmente es necesario mantener el árbol sintáctico y el grafo de dependencias. La construcción del grafo de dependencias consume tiempo y memoria. Para una GA del tamaño comúnmente usado en la práctica los requerimientos de memoria pueden ser considerables.

El tiempo de procesamiento insumido en la construcción del grafo de dependencias puede ser mayor que el proceso de evaluación en sí mismo. Los evaluadores dinámicos no han tenido mucho interés en el desarrollo de herramientas de generación de procesadores de lenguajes como por ejemplo los compiladores, porque uno de los principales requisitos de un compilador es que sea eficiente, ya que durante un desarrollo un programador generalmente necesita recompilar un número muy importante de veces hasta obtener una versión final del programa requerido.

Razón por la cual en el presente trabajo se pone énfasis en métodos de evaluación estática, y no se profundizará en los métodos dinámicos

\subsection{Evaluación estática}
Los métodos estáticos deben tener en cuenta todos los posibles árboles sintácticos posibles a ser generados por la gramática y calcular todas las posibles dependencias entre las instancias de los atributos. Además, se deberán detectar las posibles dependencias circulares, para informar la viabilidad de su evaluación.

\section{Secuencia de visita}
\section{Generación de evaluadores para GA bien definidas}
\section{Evaluación durante el parsing}

bla bla

