\chapter{Evaluación estática de MAG}
\label{chap:eval_est}
\minitoc

En este capítulo se presentan los algoritmos de construcción de cada tipo de grafo, así como los usados para el cómputo de planes de evaluación y sus respectivas secuencias de visita. Los mismos se basan en los propuestos por Wuu Yang en \cite{wuu-yang1}. Mientras que el algoritmo para el cálculo de secuencias de visita fue íntegramente desarrollado e implementado en el marco de la tesis.

Para comprobar la correctitud de los algoritmos y lograr mayor grado de eficiencia, los mismos fueron testeados mediante la herramienta \textit{gcov}\footnote{Detalles en sección \ref{sec:metoherram}.}. La cual fue utilizada con mayor énfasis para el algoritmo de cómputo de secuencias de visita. En conjunto con los resultados proporcionados por \textit{gcov} y análisis teóricos, la heurística que implementa el algoritmo fue refinada en varias oportunidades.

\section{Algoritmos para cómputo de grafos}

Todos estos algoritmos tienen una característica en común, expresan las dependencias existentes entre los atributos de una gramática desde distinto aspectos. Por lo tanto en su construcción, los nodos y aristas son obtenidos de las relaciones entre dichos elementos.

\subsection{Cómputo de DP}
\label{subsec:alg-DP}
Se debe generar un grafo DP por cada regla de la gramática, representando las dependencias directas entre los atributos de los símbolos que participan en la producción, tal como se analizó en el capítulo anterior en la sección \ref{subsec:graph-dp-def}.

Es el más directo de construir, ya que por cada ecuación de la regla actual, se agrega una arista entre cada uno de los símbolos del \texttt{r-value} con destino el \texttt{l-value} de la ecuación. Obviamente se deben agregan los nodos necesarios y sin repeticiones, para cada una de las instancias de atributos.

\begin{algorithm}[H]
\lstinputlisting[language=specmag, numbers=left, columns=fullflexible]{input_file_code/compute_dp_wuu_yang}
\caption{\label{alg:graphdp} Cómputo de grafos \textit{DP}}
\end{algorithm}

\subsection{Cómputo de Down}
\label{subsec:alg-DOWN}
Este tipo de grafo, se debe crear para cada uno de los símbolos no terminales de la gramática. Representan las relaciones de dependencia entre solamente sus atributos, considerando todas las reglas en las que participan (Ver sección \ref{subsec:graph-down-def} del capítulo anterior).

\begin{algorithm}[H]
\lstinputlisting[language=specmag, numbers=left, columns=fullflexible]{input_file_code/compute_down_wuu_yang}
\caption{\label{alg:graphdown} Cómputo de grafos \textit{Down}}
\end{algorithm}

La función \texttt{project} recibe un grafo, del cual debe eliminar todos los nodos y aristas relacionadas que no pertenecen al conjunto de atributos que le pasan como segundo parámetro. Pero para evitar que al eliminar nodos y aristas el grafo pierda información sobre las dependencias entre los atributos, se calcula previamente la clausura transitiva del grafo.

\begin{algorithm}[H]
\lstinputlisting[language=specmag, numbers=left, columns=fullflexible]{input_file_code/project_wuu_yang}
\caption{\label{alg:graphproj} Proyección sobre grafos}
\end{algorithm}

\subsection{Cómputo de DCG}
\label{subsec:alg-DCG}
Estos grafos se generan para cada regla de la gramática y considerando las dependencias entre los atributos del símbolo de la parte izquierda de la producción (\texttt{head}). Para computarlo, tal como se lo definió en la sección \ref{subsec:graph-dcg-def}, se deben unir el grafo \textit{DP} de la regla junto a todos los grafos \textit{Down} de los símbolos de la parte derecha de la regla (\texttt{body}). Se utiliza nuevamente la función \texttt{project}.

\begin{algorithm}[H]
\lstinputlisting[language=specmag, numbers=left, columns=fullflexible]{input_file_code/compute_dcg_wuu_yang}
\caption{\label{alg:graphdcg} Cómputo de grafos \textit{DCG}}
\end{algorithm}

\subsection{Cómputo de ADP}
\label{subsec:alg-ADP} 
Para generar estos grafos, Wuu Yang no plantea un algoritmo preciso aunque no es necesario ya que toda la heurística necesaria se encuentra en la definición de los mismos (ver \ref{mag:adpdef}).

Un grafo ADP corresponde a una regla bajo una cierta combinación de producciones para cada uno de sus hijos. Es decir, que para una misma regla pueden existir varios grafos ADP, ya que sus hijos pueden producir más de un contexto.

\begin{algorithm}[H]
\lstinputlisting[language=specmag, numbers=left, columns=fullflexible]{input_file_code/compute_adp_wuu_yang}
\caption{\label{alg:graphadp} Cómputo de grafos \textit{ADP}}
\end{algorithm}

\section{Algoritmo de cómputo de planes}
\label{sec:comp-planes}
Luego de verificar que la gramática es MAG\footnote{Ver \ref{def:MAG}.}, se deben generar los planes de evaluación para la gramática. Cada ADP producirá un plan de evaluación, por lo que ambos tendrán el mismo identificador, es decir, la regla a la cual pertenece y el contexto que se aplicó a los símbolos no terminales de la misma.

Este algoritmo propuesto por Wuu Yang, es detallado en profundidad. La correctitud del algoritmo es abordado por Wuu Yang en \cite{wuu-yang1}.

La idea principal es utilizar una cola de trabajos, en la cual se insertan pares que contienen una regla y un orden de evaluación para sus instancias. Para cada uno de los grafos ADP asociados a la regla, se le computa su orden de evaluación para el contexto especificado por el grafo.

Luego, para cada uno de los símbolos no terminales de la parte derecha de la regla, considerando la producción que le corresponde según el contexto, se obtiene el plan proyectado. Ese nuevo par, se intenta insertar en la cola de trabajos para seguir con el cómputo de planes.

\begin{algorithm}[H]
\lstinputlisting[language=specmag, numbers=left, columns=fullflexible]{input_file_code/compute_plan_wuu_yang}
\caption{\label{alg:planeval} Cómputo de planes de evaluación}
\end{algorithm}

La función \texttt{compute\_order}, debe agregarle al grafo ADP la información inducida por el orden para evaluar los atributos del símbolo \textbf{head} de la regla a la que pertenece el grafo.

Para ello, como todo orden se puede ver como una secuencia, se agregan al grafo un nodo por cada elementos del orden y las aristas para todos los pares posibles\footnote{Ver más detalles en \ref{sec:genplanes}}.

\begin{algorithm}[H]
\lstinputlisting[language=specmag, numbers=left, columns=fullflexible]{input_file_code/compute_order_wuu_yang}
\caption{Cómputo de orden de evaluación}
\end{algorithm}

La funcionalidad que cumple \texttt{project}, es dado un orden de evaluación purgarlo de todo elemento ajeno a el conjunto de ocurrencias de atributos especificados como parámetro. Previamente se debe aplicarle la clausura transitiva para conservar las relaciones de precedencia entre las ocurrencias.

\begin{algorithm}[H]
\lstinputlisting[language=specmag, numbers=left, columns=fullflexible]{input_file_code/project2_wuu_yang}
\caption{\label{alg:projordeval} Proyección sobre orden de evaluación}
\end{algorithm}

\section{Algoritmo de cómputo de secuencias de visita}
\label{sec:algseqvisit}

Las secuencias de visitas, son traducciones de los planes de evaluación en secuencias compuestas por tres comandos\footnote{\texttt{compute}, \texttt{leave} y \texttt{visit}, ver más detalles en \ref{sec:sec-visit}.} que permitan la navegación por el AST para su evaluación.

Este proceso fue diseñado e implementado para el desarrollo de \maggen. La generación se dividió en dos algoritmos, el primero se encarga de la inicialización de todas las secuencias de visitas y la invocación del segundo solamente para los planes de evaluación que pertenecen a la producción inicial de la gramática.

La traducción bajo demanda de los planes de evaluación, permite realizar optimizaciones como se explicará en el capítulo \ref{chap:implem} de implementación.

\begin{algorithm}[H]
\lstinputlisting[language=specmag, numbers=left, columns=fullflexible]{input_file_code/generate_visit_sequences}
\caption{\label{alg:genvisitseq} Generador de secuencias de visitas}
\end{algorithm}

El segundo realiza un proceso recursivo para lograr la traducción. Se lo puede considerar como una simulación del recorrido sobre el árbol en tiempo de evaluación. En la sección \ref{sec:constseqvisit} se ampliará este funcionamiento.

Por lo que se debe llevar una secuencia de visita local, a la cual se le insertarán los distintos comandos. Además, será necesario una función que lleve las instancias de atributos ya calculadas.

De esta forma, cuando se detecta un \texttt{visit}, se debe localizar a que hijo tiene que recursar en base al plan actual, el cual tiene un contexto establecido. Además se debe determinar el plan proyectado que actuará de orden de evaluación impuesto en la recursión. Al volver se debe actualizar todas las instancias de atributos que fueron computadas en el contexto inferior, para evitar futuras visitas innecesarias.

Con el mismo criterio, al producirse un \texttt{leave} por la necesidad de requerir que en el contexto superior se calcule una instancia de atributo, puede ser que se calculen más de lo que solicitó, por eso se deben actualizar la información de computados.

Una ecuación se podrá computar solamente cuando todo su \texttt{r-value} halla sido marcado como computado, ya sea mediante un \texttt{visit} o \texttt{leave}.

Por último, es necesario una función que combine y actualice la secuencia de visita global, con la que se calculó a nivel local. Esto es, ya que, una secuencia de visita puede ser completada en más de una visita.

\begin{algorithm}[H]
\lstinputlisting[language=specmag, numbers=left, columns=fullflexible]{input_file_code/gen_visit_seq}
\caption{\label{alg:genvisitseqrec} Función recursiva de generación de secuencias de visita}
\end{algorithm}

\section{Algoritmo de evaluación de atributos}
\label{sec:algevalattr}

Este algoritmo, no se encuentra implementado dentro de \maggen, sino que dentro del código del evaluador generado.

Se basa en dos etapas bien definidas y con propósitos diferentes. En las cuales se deben realizar dos recorridos del AST de entrada.

El primero es una barrida descendente en la que se seleccionan los planes de evaluación para cada nodo, para lo cual se debe armar su contexto en base a la regla referenciada por el nodo actual y la que poseen cada uno de sus hijos. El orden de evaluación de atributos para la raíz del AST es aleatoria, ya que sólo contiene símbolos sintetizados y no pueden ser utilizados en otro contexto por ser una gramática extendida.

En el segundo recorrido, no precisamente se realiza en un sentido uniforme, sino que se navega descendente y ascendentemente, de acuerdo a la secuencia de visita correspondiente al plan seleccionado en la primera etapa. Este algoritmo, Wuu Yang no lo presenta y lo deja a libre elección del usuario. En \ref{sec:codcppalgeval} se presenta el evaluador guiado por visita implementado para \maggen.

\begin{algorithm}[H]
\lstinputlisting[language=specmag, numbers=left, columns=fullflexible]{input_file_code/eval_attribute_wuu_yang}
\caption{\label{alg:evalattr} Evaluación de atributos}
\end{algorithm}

Esta función, tiene toda la información necesaria ya precargada, gracias al procesamiento previo de los anteriores algoritmos. Debe determinar el plan de evaluación, almacenado en $\Gamma$, armando la clave con la regla asociada al nodo corriente y las reglas asociadas de todos los hijos. El orden de evaluación de atributos $\omega$, le viene como parámetro, el cual corresponde con un plan de evaluación proyectado, que desde el contexto superior le impusieron. Una vez seleccionado el plan, también queda establecida la secuencia de visita, para el nodo.

Para continuar con el proceso, se debe seleccionar para cada hijo el plan proyectado desde $\Theta$, que será el orden que le imponen para la evaluación de sus atributos.

\begin{algorithm}[H]
\lstinputlisting[language=specmag, numbers=left, columns=fullflexible]{input_file_code/traverse_wuu_yang}
\caption{\label{alg:traverse} Función Traverse}
\end{algorithm}