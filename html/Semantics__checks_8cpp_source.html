<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>maggen: src/Parser/Semantics_checks.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>src/Parser/Semantics_checks.cpp</h1><a href="Semantics__checks_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="preprocessor">#include &quot;../../include/Parser/Semantics_checks.h&quot;</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="keyword">using namespace </span>std;
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 <span class="keyword">namespace </span>genevalmag
<a name="l00019"></a>00019 {
<a name="l00020"></a>00020 
<a name="l00024"></a><a class="code" href="classgenevalmag_1_1Semantics__checks.html#a332b806015b2d142ebaaa5ec5f7f6078">00024</a> <a class="code" href="classgenevalmag_1_1Semantics__checks.html#a332b806015b2d142ebaaa5ec5f7f6078">Semantics_checks::Semantics_checks</a>()
<a name="l00025"></a>00025 {
<a name="l00026"></a>00026         <a class="code" href="classgenevalmag_1_1Semantics__checks.html#ae69cd5c1a7b7d2cfa05c370617a8d58f">precedence_level</a>        = 0;
<a name="l00027"></a>00027         <a class="code" href="classgenevalmag_1_1Semantics__checks.html#a7dcdb23df315da76ae288462e3427591" title="Counter of syntax order.">index_syntax_order</a>      = 0;
<a name="l00028"></a>00028 }
<a name="l00029"></a>00029 
<a name="l00033"></a><a class="code" href="classgenevalmag_1_1Semantics__checks.html#a77ad2416d9844554db3602939a9f462c">00033</a> <a class="code" href="classgenevalmag_1_1Semantics__checks.html#a77ad2416d9844554db3602939a9f462c">Semantics_checks::~Semantics_checks</a>()
<a name="l00034"></a>00034 {
<a name="l00035"></a>00035 }
<a name="l00036"></a>00036 
<a name="l00040"></a><a class="code" href="classgenevalmag_1_1Semantics__checks.html#ad6b0e8d52900149631ae1d38ce61bf94">00040</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <a class="code" href="classgenevalmag_1_1Semantics__checks.html#ad6b0e8d52900149631ae1d38ce61bf94">Semantics_checks::get_precedence_level</a>()<span class="keyword"> const</span>
<a name="l00041"></a>00041 <span class="keyword"></span>{
<a name="l00042"></a>00042     <span class="keywordflow">return</span> <a class="code" href="classgenevalmag_1_1Semantics__checks.html#ae69cd5c1a7b7d2cfa05c370617a8d58f">precedence_level</a>;
<a name="l00043"></a>00043 }
<a name="l00044"></a>00044 
<a name="l00048"></a><a class="code" href="classgenevalmag_1_1Semantics__checks.html#a6d51fcd1f3ed2d6bf5470de0fb5b7770">00048</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <a class="code" href="classgenevalmag_1_1Semantics__checks.html#a6d51fcd1f3ed2d6bf5470de0fb5b7770">Semantics_checks::get_index_syntax_order</a>()<span class="keyword"> const</span>
<a name="l00049"></a>00049 <span class="keyword"></span>{
<a name="l00050"></a>00050     <span class="keywordflow">return</span> <a class="code" href="classgenevalmag_1_1Semantics__checks.html#a7dcdb23df315da76ae288462e3427591" title="Counter of syntax order.">index_syntax_order</a>;
<a name="l00051"></a>00051 }
<a name="l00052"></a>00052 
<a name="l00056"></a><a class="code" href="classgenevalmag_1_1Semantics__checks.html#ae9e488640f503bbd04a212f282f48826">00056</a> <span class="keywordtype">void</span> <a class="code" href="classgenevalmag_1_1Semantics__checks.html#ae9e488640f503bbd04a212f282f48826">Semantics_checks::increment_precedence_level</a>()
<a name="l00057"></a>00057 {
<a name="l00058"></a>00058         <a class="code" href="classgenevalmag_1_1Semantics__checks.html#ae69cd5c1a7b7d2cfa05c370617a8d58f">precedence_level</a>++;
<a name="l00059"></a>00059 }
<a name="l00060"></a>00060 
<a name="l00064"></a><a class="code" href="classgenevalmag_1_1Semantics__checks.html#a0596851fd5b0e972d7b21a116141e154">00064</a> <span class="keywordtype">void</span> <a class="code" href="classgenevalmag_1_1Semantics__checks.html#a0596851fd5b0e972d7b21a116141e154">Semantics_checks::decrement_precedence_level</a>()
<a name="l00065"></a>00065 {
<a name="l00066"></a>00066         <a class="code" href="classgenevalmag_1_1Semantics__checks.html#ae69cd5c1a7b7d2cfa05c370617a8d58f">precedence_level</a>--;
<a name="l00067"></a>00067 }
<a name="l00068"></a>00068 
<a name="l00072"></a><a class="code" href="classgenevalmag_1_1Semantics__checks.html#ac755d47def82c431fa38053a58f231b6">00072</a> <span class="keywordtype">void</span> <a class="code" href="classgenevalmag_1_1Semantics__checks.html#ac755d47def82c431fa38053a58f231b6">Semantics_checks::increment_index_syntax_order</a>()
<a name="l00073"></a>00073 {
<a name="l00074"></a>00074         <a class="code" href="classgenevalmag_1_1Semantics__checks.html#a7dcdb23df315da76ae288462e3427591" title="Counter of syntax order.">index_syntax_order</a>++;
<a name="l00075"></a>00075 }
<a name="l00076"></a>00076 
<a name="l00080"></a><a class="code" href="classgenevalmag_1_1Semantics__checks.html#a26db5c186627aa6fcfc8e69b26b7706c">00080</a> <span class="keywordtype">void</span> <a class="code" href="classgenevalmag_1_1Semantics__checks.html#a26db5c186627aa6fcfc8e69b26b7706c">Semantics_checks::reset_semantic_context</a>()
<a name="l00081"></a>00081 {
<a name="l00082"></a>00082         <a class="code" href="classgenevalmag_1_1Semantics__checks.html#ae69cd5c1a7b7d2cfa05c370617a8d58f">precedence_level</a>        = 0;
<a name="l00083"></a>00083         <a class="code" href="classgenevalmag_1_1Semantics__checks.html#a7dcdb23df315da76ae288462e3427591" title="Counter of syntax order.">index_syntax_order</a>      = 0;
<a name="l00084"></a>00084 }
<a name="l00085"></a>00085 
<a name="l00107"></a><a class="code" href="namespacegenevalmag.html#a5132358a5088f64e976aa18643cff4d8">00107</a> <span class="keywordtype">int</span> <a class="code" href="namespacegenevalmag.html#a5132358a5088f64e976aa18643cff4d8">swap_root_child</a>(<a class="code" href="classgenevalmag_1_1Expr__function.html">Expr_function</a> **old_root, <span class="keywordtype">int</span> i_new_root)
<a name="l00108"></a>00108 {
<a name="l00109"></a>00109         <a class="code" href="classgenevalmag_1_1Expr__function.html">Expr_function</a> *new_root((<a class="code" href="classgenevalmag_1_1Expr__function.html">Expr_function</a>*)(*old_root)-&gt;get_child(i_new_root));
<a name="l00110"></a>00110         new_root-&gt;set_parent((*old_root)-&gt;get_parent());
<a name="l00111"></a>00111 
<a name="l00112"></a>00112         <span class="keywordtype">int</span> index_swap(-1);
<a name="l00113"></a>00113         <span class="keywordflow">if</span> (new_root-&gt;is_infix())
<a name="l00114"></a>00114         {
<a name="l00115"></a>00115                 index_swap = (i_new_root == 0)? 1: 0;
<a name="l00116"></a>00116         }
<a name="l00117"></a>00117         <span class="keywordflow">else</span>
<a name="l00118"></a>00118         {
<a name="l00119"></a>00119                 index_swap = 0;
<a name="l00120"></a>00120         }
<a name="l00121"></a>00121 
<a name="l00122"></a>00122         <span class="comment">/* Get E.  Get D. */</span>
<a name="l00123"></a>00123         <a class="code" href="classgenevalmag_1_1Expression.html">Expression</a> *aux(new_root-&gt;get_child(index_swap));
<a name="l00124"></a>00124         <span class="comment">/* Set child E to A. Set child D to A. */</span>
<a name="l00125"></a>00125         (*old_root)-&gt;replace_child(i_new_root, aux);
<a name="l00126"></a>00126         <span class="comment">/* Set child A to B. Set child A to C. */</span>
<a name="l00127"></a>00127         new_root-&gt;replace_child(index_swap, (*old_root));
<a name="l00128"></a>00128         <span class="comment">/* Set new root B or C.*/</span>
<a name="l00129"></a>00129         (*old_root) = new_root;
<a name="l00130"></a>00130 
<a name="l00131"></a>00131         <span class="keywordflow">return</span> index_swap;
<a name="l00132"></a>00132 }
<a name="l00133"></a>00133 
<a name="l00145"></a><a class="code" href="namespacegenevalmag.html#a18228f21bca4decde649041801026a35">00145</a> <span class="keywordtype">int</span> <a class="code" href="namespacegenevalmag.html#a18228f21bca4decde649041801026a35">swap_root_grandson</a>(<a class="code" href="classgenevalmag_1_1Expr__function.html">Expr_function</a> **old_root)
<a name="l00146"></a>00146 {
<a name="l00147"></a>00147         <a class="code" href="classgenevalmag_1_1Expr__function.html">Expr_function</a> *new_root((<a class="code" href="classgenevalmag_1_1Expr__function.html">Expr_function</a> *)(*old_root)-&gt;get_child(0));
<a name="l00148"></a>00148 
<a name="l00149"></a>00149         <span class="keywordtype">int</span> index_swap(-1);
<a name="l00150"></a>00150         <span class="keywordflow">if</span> (new_root-&gt;is_infix())
<a name="l00151"></a>00151         {
<a name="l00152"></a>00152                 index_swap = 1;
<a name="l00153"></a>00153         }
<a name="l00154"></a>00154         <span class="keywordflow">else</span>
<a name="l00155"></a>00155         {
<a name="l00156"></a>00156                 <span class="comment">/* VER CASO DE PREFIJA. */</span>
<a name="l00157"></a>00157                 index_swap = 0;
<a name="l00158"></a>00158         }
<a name="l00159"></a>00159 
<a name="l00160"></a>00160         <a class="code" href="classgenevalmag_1_1Expr__function.html">Expr_function</a> *swap((<a class="code" href="classgenevalmag_1_1Expr__function.html">Expr_function</a> *)new_root-&gt;get_child(index_swap));
<a name="l00161"></a>00161         new_root-&gt;set_parent((*old_root)-&gt;get_parent());
<a name="l00162"></a>00162         <a class="code" href="classgenevalmag_1_1Expression.html">Expression</a> *grandson(swap-&gt;get_child(0));
<a name="l00163"></a>00163         (*old_root)-&gt;replace_child(0, grandson);
<a name="l00164"></a>00164         swap-&gt;replace_child(0, (*old_root));
<a name="l00165"></a>00165         (*old_root) = new_root;
<a name="l00166"></a>00166         <span class="keywordflow">return</span> index_swap;
<a name="l00167"></a>00167 }
<a name="l00168"></a>00168 
<a name="l00172"></a><a class="code" href="classgenevalmag_1_1Semantics__checks.html#ae7d4a6bbf2eebde377bc386983f61002">00172</a> <span class="keywordtype">void</span> <a class="code" href="classgenevalmag_1_1Semantics__checks.html#ae7d4a6bbf2eebde377bc386983f61002">Semantics_checks::correct_subtree</a>(<a class="code" href="classgenevalmag_1_1Expr__function.html">Expr_function</a> **subtree, <span class="keywordtype">int</span> index_root_subtree)
<a name="l00173"></a>00173 {
<a name="l00174"></a>00174         <a class="code" href="classgenevalmag_1_1Expr__function.html">Expr_function</a> *aux((<a class="code" href="classgenevalmag_1_1Expr__function.html">Expr_function</a>*)(*subtree)-&gt;get_child(index_root_subtree));
<a name="l00175"></a>00175         <a class="code" href="classgenevalmag_1_1Semantics__checks.html#a5ad77ec398637204eea7e88b5d4fa74e">correct_precedence</a>(&amp;aux);
<a name="l00176"></a>00176 
<a name="l00177"></a>00177         <span class="comment">/* Update new son by the result of recursion. */</span>
<a name="l00178"></a>00178         (*subtree)-&gt;replace_child(index_root_subtree,aux);
<a name="l00179"></a>00179 
<a name="l00180"></a>00180         <span class="keywordflow">if</span> (((*subtree)-&gt;compare_precedence(aux) &gt; 0) &amp;&amp; ((*subtree)-&gt;is_comparable(aux)))
<a name="l00181"></a>00181         <span class="comment">/* The root and the child are at the same level of precedence.</span>
<a name="l00182"></a>00182 <span class="comment">         * The root should be applied first.</span>
<a name="l00183"></a>00183 <span class="comment">         */</span>
<a name="l00184"></a>00184         {
<a name="l00185"></a>00185                 <span class="keywordflow">if</span> ((((*subtree)-&gt;compare_order(aux) &gt; 0) &amp;&amp; aux-&gt;is_prefix()) ||
<a name="l00186"></a>00186                         (((*subtree)-&gt;compare_order(aux) &lt; 0) &amp;&amp; aux-&gt;is_postfix()))
<a name="l00187"></a>00187                 <span class="comment">/* It makes the change only if does not change the syntactic order.</span>
<a name="l00188"></a>00188 <span class="comment">                 * An operation should be introduced within a prefix or postfix.</span>
<a name="l00189"></a>00189 <span class="comment">                 */</span>
<a name="l00190"></a>00190                 {
<a name="l00191"></a>00191                         <a class="code" href="namespacegenevalmag.html#a5132358a5088f64e976aa18643cff4d8">swap_root_child</a>(subtree, index_root_subtree);
<a name="l00192"></a>00192                 }
<a name="l00193"></a>00193         }
<a name="l00194"></a>00194 }
<a name="l00195"></a>00195 
<a name="l00209"></a><a class="code" href="classgenevalmag_1_1Semantics__checks.html#a5ad77ec398637204eea7e88b5d4fa74e">00209</a> <span class="keywordtype">void</span> <a class="code" href="classgenevalmag_1_1Semantics__checks.html#a5ad77ec398637204eea7e88b5d4fa74e">Semantics_checks::correct_precedence</a>(<a class="code" href="classgenevalmag_1_1Expr__function.html">Expr_function</a> **root_tree)
<a name="l00210"></a>00210 {
<a name="l00211"></a>00211         <span class="keywordflow">if</span> (!(*root_tree)-&gt;is_prefix() &amp;&amp; ((*root_tree)-&gt;get_child(0)-&gt;get_conflict() &gt; -1))
<a name="l00212"></a>00212         <span class="comment">/* Special case which must complete a check of some sub-level of the tree. */</span>
<a name="l00213"></a>00213         {
<a name="l00214"></a>00214                 <span class="keywordflow">if</span> (((*root_tree)-&gt;get_function()-&gt;get_prec() &gt; (*root_tree)-&gt;get_child(0)-&gt;get_conflict()) &amp;&amp;
<a name="l00215"></a>00215                         ((*root_tree)-&gt;is_comparable((<a class="code" href="classgenevalmag_1_1Expr__function.html">Expr_function</a>*)(*root_tree)-&gt;get_child(0))))
<a name="l00216"></a>00216                 <span class="comment">/* Same level precedence and change is needed to correct conflict of precedence. */</span>
<a name="l00217"></a>00217                 {
<a name="l00218"></a>00218                         <span class="keywordtype">int</span> i_subtree(<a class="code" href="namespacegenevalmag.html#a18228f21bca4decde649041801026a35">swap_root_grandson</a>(root_tree));
<a name="l00219"></a>00219 
<a name="l00220"></a>00220                         <span class="comment">/* Checks that the subtree with the older root is well formed. */</span>
<a name="l00221"></a>00221                         <a class="code" href="classgenevalmag_1_1Expr__function.html">Expr_function</a> *subtree((<a class="code" href="classgenevalmag_1_1Expr__function.html">Expr_function</a>*)(*root_tree)-&gt;get_child(i_subtree));
<a name="l00222"></a>00222                         <a class="code" href="classgenevalmag_1_1Semantics__checks.html#ae7d4a6bbf2eebde377bc386983f61002">correct_subtree</a>(&amp;subtree,0);
<a name="l00223"></a>00223 
<a name="l00224"></a>00224                         <span class="comment">/* Updates the main tree, with the new root of subtree. */</span>
<a name="l00225"></a>00225                         (*root_tree)-&gt;replace_child(i_subtree,subtree);
<a name="l00226"></a>00226 
<a name="l00227"></a>00227                         <span class="comment">/* Only requires checking the main tree root with his new son. */</span>
<a name="l00228"></a>00228                         <a class="code" href="classgenevalmag_1_1Semantics__checks.html#a5ad77ec398637204eea7e88b5d4fa74e">correct_precedence</a>(root_tree);
<a name="l00229"></a>00229                 }
<a name="l00230"></a>00230                 <span class="comment">/* Turn off the flag. */</span>
<a name="l00231"></a>00231                 (*root_tree)-&gt;get_child(0)-&gt;desactive_conflict();
<a name="l00232"></a>00232                 <span class="comment">/* Don&#39;t necesary continue with normal behavior, because the special case performs all change. */</span>
<a name="l00233"></a>00233                 <span class="keywordflow">return</span>;
<a name="l00234"></a>00234         }
<a name="l00235"></a>00235 
<a name="l00236"></a>00236         <span class="comment">/* Normal behavior. */</span>
<a name="l00237"></a>00237         <span class="keywordtype">int</span> i_child(0);
<a name="l00238"></a>00238         <span class="keywordflow">while</span> (i_child &lt; (*root_tree)-&gt;get_function()-&gt;get_arity())
<a name="l00239"></a>00239         <span class="comment">/* It covers all children. */</span>
<a name="l00240"></a>00240         {
<a name="l00241"></a>00241                 <span class="comment">/* Detecting if the child is of Expr_function type. */</span>
<a name="l00242"></a>00242                 <a class="code" href="classgenevalmag_1_1Expr__function.html">Expr_function</a> *node(dynamic_cast&lt;Expr_function*&gt;((*root_tree)-&gt;get_child(i_child)));
<a name="l00243"></a>00243 
<a name="l00244"></a>00244                 <span class="keywordflow">if</span> (node)
<a name="l00245"></a>00245                 <span class="comment">/* The node is the Expr_function because the dynamic cast was successfully. */</span>
<a name="l00246"></a>00246                 {
<a name="l00247"></a>00247                         <span class="keywordflow">if</span> (((*root_tree)-&gt;compare_precedence(node) &gt; 0) &amp;&amp; ((*root_tree)-&gt;is_comparable(node)))
<a name="l00248"></a>00248                         <span class="comment">/* Same level precedence and detection of posible swap. */</span>
<a name="l00249"></a>00249                         {
<a name="l00250"></a>00250                                 <span class="keywordflow">if</span> (((*root_tree)-&gt;is_prefix() &amp;&amp; node-&gt;<a class="code" href="classgenevalmag_1_1Expr__function.html#a0534ddcde21e3bd35fe12e85f6d8251f">is_prefix</a>()) ||
<a name="l00251"></a>00251                                         ((*root_tree)-&gt;is_postfix() &amp;&amp; node-&gt;<a class="code" href="classgenevalmag_1_1Expr__function.html#a8ef52d8fec97d084be0b24e5207a0551">is_postfix</a>()))
<a name="l00252"></a>00252                                 <span class="comment">/* Case of nested prefix or postfix operations. */</span>
<a name="l00253"></a>00253                                 {
<a name="l00254"></a>00254                                         i_child++;
<a name="l00255"></a>00255                                         <span class="keywordflow">continue</span>;
<a name="l00256"></a>00256                                 }
<a name="l00257"></a>00257 
<a name="l00258"></a>00258                                 <span class="keywordflow">if</span> (((*root_tree)-&gt;compare_order(node) &lt; 0) &amp;&amp; node-&gt;<a class="code" href="classgenevalmag_1_1Expr__function.html#a0534ddcde21e3bd35fe12e85f6d8251f">is_prefix</a>())
<a name="l00259"></a>00259                                 <span class="comment">/* Discart swap because affect the syntax order. */</span>
<a name="l00260"></a>00260                                 {
<a name="l00261"></a>00261                                         <span class="comment">/* It turns on the flag of conflict to check into special case. */</span>
<a name="l00262"></a>00262                                         (*root_tree)-&gt;active_conflict(node-&gt;<a class="code" href="classgenevalmag_1_1Expr__function.html#a7f1fedb3efc2c8eaf07877a8e72a2579">get_function</a>()-&gt;<a class="code" href="classgenevalmag_1_1Function.html#a31272821c5ad532ada3b3d8a988f5891">get_prec</a>());
<a name="l00263"></a>00263                                         i_child++;
<a name="l00264"></a>00264                                         <span class="keywordflow">continue</span>;
<a name="l00265"></a>00265                                 }
<a name="l00266"></a>00266 
<a name="l00267"></a>00267                                 <span class="keywordflow">if</span> (((*root_tree)-&gt;compare_order(node) &gt; 0) &amp;&amp; node-&gt;<a class="code" href="classgenevalmag_1_1Expr__function.html#a8ef52d8fec97d084be0b24e5207a0551">is_postfix</a>())
<a name="l00268"></a>00268                                 <span class="comment">/* Discart swap because affect the syntax order. */</span>
<a name="l00269"></a>00269                                 {
<a name="l00270"></a>00270                                         i_child++;
<a name="l00271"></a>00271                                         <span class="keywordflow">continue</span>;
<a name="l00272"></a>00272                                 }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274                                 <span class="comment">/* Performs the swap in normal conditions. */</span>
<a name="l00275"></a>00275                                 <span class="keywordtype">int</span> index_child(<a class="code" href="namespacegenevalmag.html#a5132358a5088f64e976aa18643cff4d8">swap_root_child</a>(root_tree, i_child));
<a name="l00276"></a>00276 
<a name="l00277"></a>00277                                 <span class="comment">/* Recursion is sent for organize the tree with the new root. */</span>
<a name="l00278"></a>00278                                 <a class="code" href="classgenevalmag_1_1Semantics__checks.html#ae7d4a6bbf2eebde377bc386983f61002">correct_subtree</a>(root_tree,index_child);
<a name="l00279"></a>00279                         }
<a name="l00280"></a>00280                 }
<a name="l00281"></a>00281                 i_child++;
<a name="l00282"></a>00282         }
<a name="l00283"></a>00283 }
<a name="l00284"></a>00284 
<a name="l00291"></a><a class="code" href="classgenevalmag_1_1Semantics__checks.html#a7cc9baa891ee17c0e4140014597c49d8">00291</a> <span class="keywordtype">void</span> <a class="code" href="classgenevalmag_1_1Semantics__checks.html#a7cc9baa891ee17c0e4140014597c49d8">Semantics_checks::correct_associativity</a>(<a class="code" href="classgenevalmag_1_1Expr__function.html">Expr_function</a> **root_tree)
<a name="l00292"></a>00292 {
<a name="l00293"></a>00293         <span class="comment">/* Detecting if the child is of Expr_function type. */</span>
<a name="l00294"></a>00294         <a class="code" href="classgenevalmag_1_1Expr__function.html">Expr_function</a> *child(dynamic_cast&lt;Expr_function*&gt;((*root_tree)-&gt;get_child(0)));
<a name="l00295"></a>00295         <span class="keywordflow">if</span>(child)
<a name="l00296"></a>00296         {
<a name="l00297"></a>00297                 <span class="keywordflow">if</span>((*root_tree)-&gt;get_function()-&gt;equals(*(child-&gt;<a class="code" href="classgenevalmag_1_1Expr__function.html#a7f1fedb3efc2c8eaf07877a8e72a2579">get_function</a>())))
<a name="l00298"></a>00298                 {
<a name="l00299"></a>00299                         <span class="keywordflow">if</span>((*root_tree)-&gt;is_comparable(child) &amp;&amp; (*root_tree)-&gt;is_infix())
<a name="l00300"></a>00300                         {
<a name="l00301"></a>00301                                 <span class="keywordflow">if</span> ((*root_tree)-&gt;get_function()-&gt;get_oper_assoc() == <a class="code" href="namespacegenevalmag.html#aed96782841eb4586b9e32ce72721d64ba3c53d98737826847326f2383d325352c">k_right</a>)
<a name="l00302"></a>00302                                 {
<a name="l00303"></a>00303                                         <a class="code" href="namespacegenevalmag.html#a5132358a5088f64e976aa18643cff4d8">swap_root_child</a>(root_tree,0);
<a name="l00304"></a>00304                                         <a class="code" href="classgenevalmag_1_1Semantics__checks.html#a7cc9baa891ee17c0e4140014597c49d8">correct_associativity</a>(root_tree);
<a name="l00305"></a>00305                                 }
<a name="l00306"></a>00306                                 <span class="keywordflow">else</span>
<a name="l00307"></a>00307                                 {
<a name="l00308"></a>00308                                         <span class="keywordflow">if</span> ((*root_tree)-&gt;get_function()-&gt;get_oper_assoc() == <a class="code" href="namespacegenevalmag.html#aed96782841eb4586b9e32ce72721d64ba0c5c27fb77ec1ddebd5ce7ab07ffc27f">k_non_assoc</a>)
<a name="l00309"></a>00309                                         {
<a name="l00310"></a>00310                                                 cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: operator non-associtive using wrong use: &quot;</span> &lt;&lt; (*root_tree)-&gt;get_function()-&gt;get_name() &lt;&lt; endl;
<a name="l00311"></a>00311                                                 exit(-1);
<a name="l00312"></a>00312                                         }
<a name="l00313"></a>00313                                 }
<a name="l00314"></a>00314                         }
<a name="l00315"></a>00315                 }
<a name="l00316"></a>00316                 <span class="keywordflow">else</span>
<a name="l00317"></a>00317                 {
<a name="l00318"></a>00318                         <a class="code" href="classgenevalmag_1_1Semantics__checks.html#a7cc9baa891ee17c0e4140014597c49d8">correct_associativity</a>(&amp;child);
<a name="l00319"></a>00319                         (*root_tree)-&gt;replace_child(0,child);
<a name="l00320"></a>00320                 }
<a name="l00321"></a>00321         }
<a name="l00322"></a>00322         <span class="keywordflow">if</span>((*root_tree)-&gt;is_infix())
<a name="l00323"></a>00323         {
<a name="l00324"></a>00324                 <a class="code" href="classgenevalmag_1_1Expr__function.html">Expr_function</a> *child_rec(dynamic_cast&lt;Expr_function*&gt;((*root_tree)-&gt;get_child(1)));
<a name="l00325"></a>00325                 <span class="keywordflow">if</span> (child_rec)
<a name="l00326"></a>00326                 {
<a name="l00327"></a>00327                         <a class="code" href="classgenevalmag_1_1Semantics__checks.html#a7cc9baa891ee17c0e4140014597c49d8">correct_associativity</a>(&amp;child_rec);
<a name="l00328"></a>00328                         (*root_tree)-&gt;replace_child(1,child_rec);
<a name="l00329"></a>00329                 }
<a name="l00330"></a>00330         }
<a name="l00331"></a>00331 }
<a name="l00332"></a>00332 
<a name="l00337"></a><a class="code" href="classgenevalmag_1_1Semantics__checks.html#abb0a26862b6134eeb10f55b701ded180">00337</a> <span class="keywordtype">bool</span> <a class="code" href="classgenevalmag_1_1Semantics__checks.html#abb0a26862b6134eeb10f55b701ded180">Semantics_checks::check_all_defined_non_terminal</a>(<span class="keyword">const</span> map &lt;unsigned short, Rule&gt; &amp;rules, <span class="keyword">const</span> map &lt;string, Symbol&gt; &amp;non_terminals)
<a name="l00338"></a>00338 {
<a name="l00339"></a>00339         <span class="keywordtype">bool</span> left_symbol_defined(<span class="keyword">false</span>);
<a name="l00340"></a>00340 
<a name="l00341"></a>00341         <span class="keywordflow">for</span> (map&lt;string,Symbol &gt;::const_iterator it_s(non_terminals.begin()); it_s != non_terminals.end(); it_s++)
<a name="l00342"></a>00342         {
<a name="l00343"></a>00343                 left_symbol_defined = <span class="keyword">false</span>;
<a name="l00344"></a>00344 
<a name="l00345"></a>00345                 map&lt;unsigned short,Rule &gt;::const_iterator it_r(rules.begin());
<a name="l00346"></a>00346                 <span class="keywordflow">while</span> (it_r != rules.end())
<a name="l00347"></a>00347                 {
<a name="l00348"></a>00348                         <span class="keywordflow">if</span> (it_s-&gt;second.equals(*(it_r-&gt;second.get_left_symbol())))
<a name="l00349"></a>00349                         {
<a name="l00350"></a>00350                                 left_symbol_defined = <span class="keyword">true</span>;
<a name="l00351"></a>00351                                 <span class="keywordflow">break</span>;
<a name="l00352"></a>00352                         }
<a name="l00353"></a>00353                         it_r++;
<a name="l00354"></a>00354                 }
<a name="l00355"></a>00355                 <span class="keywordflow">if</span> (!left_symbol_defined)
<a name="l00356"></a>00356                 {
<a name="l00357"></a>00357                         cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: Symbol Non-Teminal \&quot;&quot;</span> &lt;&lt; it_s-&gt;second.get_name() &lt;&lt; <span class="stringliteral">&quot;\&quot; uses in the right part without rule.&quot;</span> &lt;&lt; endl;
<a name="l00358"></a>00358                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00359"></a>00359                 }
<a name="l00360"></a>00360         }
<a name="l00361"></a>00361         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00362"></a>00362 }
<a name="l00363"></a>00363 
<a name="l00367"></a><a class="code" href="namespacegenevalmag.html#a311f0385029ff37574bbf0189064f310">00367</a> <span class="keywordtype">void</span> <a class="code" href="namespacegenevalmag.html#a311f0385029ff37574bbf0189064f310">warshall_algorithm</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size, <span class="keywordtype">bool</span> *matrix_plain)
<a name="l00368"></a>00368 {
<a name="l00369"></a>00369         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k(0); k &lt; size; k++)
<a name="l00370"></a>00370         {
<a name="l00371"></a>00371                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i(0); i &lt; size; i++)
<a name="l00372"></a>00372                 {
<a name="l00373"></a>00373                         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j(0); j &lt; size; j++)
<a name="l00374"></a>00374                         {
<a name="l00375"></a>00375                                 <span class="comment">/* Assign new value from: M[i][j] = M[i][j] OR (M[i][k] AND M[k][j]). */</span>
<a name="l00376"></a>00376                                 (matrix_plain + (size*i))[j] =
<a name="l00377"></a>00377                                                 (matrix_plain + (size*i))[j] ||
<a name="l00378"></a>00378                                                 ((matrix_plain + (size*i))[k] &amp;&amp; (matrix_plain + (size*k))[j]);
<a name="l00379"></a>00379                         }
<a name="l00380"></a>00380                 }
<a name="l00381"></a>00381         }
<a name="l00382"></a>00382 }
<a name="l00383"></a>00383 
<a name="l00387"></a><a class="code" href="namespacegenevalmag.html#a6442b82b3f1265663c5bdb2bc80f4421">00387</a> <span class="keywordtype">int</span> <a class="code" href="namespacegenevalmag.html#a6442b82b3f1265663c5bdb2bc80f4421">get_index</a>(<span class="keywordtype">string</span> name_symb, vector&lt;string&gt; non_term)
<a name="l00388"></a>00388 {
<a name="l00389"></a>00389         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i(0); i&lt; non_term.size();i++)
<a name="l00390"></a>00390         {
<a name="l00391"></a>00391                 <span class="keywordflow">if</span> (name_symb.compare(non_term[i]) == 0)
<a name="l00392"></a>00392                 {
<a name="l00393"></a>00393                         <span class="comment">/* Elem found. Return index of elem. */</span>
<a name="l00394"></a>00394                         <span class="keywordflow">return</span> i;
<a name="l00395"></a>00395                 }
<a name="l00396"></a>00396         }
<a name="l00397"></a>00397         <span class="comment">/* The elem isn&#39;t in the vector. */</span>
<a name="l00398"></a>00398         <span class="keywordflow">return</span> -1;
<a name="l00399"></a>00399 }
<a name="l00400"></a>00400 
<a name="l00406"></a><a class="code" href="classgenevalmag_1_1Semantics__checks.html#a6d2a6d53c499f3e7abbd19ecbc0d69d5">00406</a> <span class="keywordtype">bool</span> <a class="code" href="classgenevalmag_1_1Semantics__checks.html#a6d2a6d53c499f3e7abbd19ecbc0d69d5">Semantics_checks::check_reachability</a>(<span class="keyword">const</span> map &lt;unsigned short, Rule&gt; &amp;rules, <span class="keyword">const</span> map &lt;string, Symbol&gt; &amp;non_terminals, <span class="keyword">const</span> <a class="code" href="classgenevalmag_1_1Symbol.html">Symbol</a> *init_symbol)
<a name="l00407"></a>00407 {
<a name="l00408"></a>00408         vector&lt;string&gt; non_term;
<a name="l00409"></a>00409         <span class="comment">/* Obtain all non_terminals name. */</span>
<a name="l00410"></a>00410         <span class="keywordflow">for</span> (map&lt;string,Symbol &gt;::const_iterator it_s(non_terminals.begin()); it_s != non_terminals.end(); it_s++)
<a name="l00411"></a>00411         {
<a name="l00412"></a>00412                 non_term.push_back(it_s-&gt;second.get_name());
<a name="l00413"></a>00413         }
<a name="l00414"></a>00414 
<a name="l00415"></a>00415         <span class="keywordtype">int</span> cant_non_terminal(non_term.size());
<a name="l00416"></a>00416 
<a name="l00417"></a>00417         <span class="keywordtype">bool</span> matrix_reachability[cant_non_terminal][cant_non_terminal];
<a name="l00418"></a>00418 
<a name="l00419"></a>00419         <span class="comment">/* Inicializer matriz. */</span>
<a name="l00420"></a>00420         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i(0); i &lt; cant_non_terminal; i++)
<a name="l00421"></a>00421         {
<a name="l00422"></a>00422                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j(0); j &lt; cant_non_terminal; j++)
<a name="l00423"></a>00423                 {
<a name="l00424"></a>00424                         matrix_reachability[i][j] = <span class="keyword">false</span>;
<a name="l00425"></a>00425                 }
<a name="l00426"></a>00426         }
<a name="l00427"></a>00427 
<a name="l00428"></a>00428         <span class="comment">/* Matrix W0 in Warshall Algorithm. */</span>
<a name="l00429"></a>00429 
<a name="l00430"></a>00430         <span class="comment">/* For each rule, set the adjacency relations of the non-terminals. */</span>
<a name="l00431"></a>00431         <span class="keywordflow">for</span> (map&lt;unsigned short,Rule &gt;::const_iterator it_r(rules.begin()); it_r != rules.end(); it_r++)
<a name="l00432"></a>00432         {
<a name="l00433"></a>00433                 <span class="keywordtype">string</span> symbol(it_r-&gt;second.get_left_symbol()-&gt;get_name());
<a name="l00434"></a>00434                 <span class="keywordtype">int</span> index_i(<a class="code" href="namespacegenevalmag.html#a6442b82b3f1265663c5bdb2bc80f4421">get_index</a>(symbol,non_term));
<a name="l00435"></a>00435 
<a name="l00436"></a>00436                 <span class="comment">/* For each non-terminal in the right side, set true cell in the matrix. */</span>
<a name="l00437"></a>00437                 <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> k(0); k &lt; it_r-&gt;second.get_right_side().size(); k++)
<a name="l00438"></a>00438                 {
<a name="l00439"></a>00439                         <span class="keywordflow">if</span> (it_r-&gt;second.get_right_side().at(k)-&gt;is_non_terminal())
<a name="l00440"></a>00440                         {
<a name="l00441"></a>00441                                 symbol = it_r-&gt;second.get_right_side().at(k)-&gt;get_name();
<a name="l00442"></a>00442                                 <span class="keywordtype">int</span> index_j(<a class="code" href="namespacegenevalmag.html#a6442b82b3f1265663c5bdb2bc80f4421">get_index</a>(symbol,non_term));
<a name="l00443"></a>00443                                 matrix_reachability[index_i][index_j] = <span class="keyword">true</span>;
<a name="l00444"></a>00444                         }
<a name="l00445"></a>00445                 }
<a name="l00446"></a>00446         }
<a name="l00447"></a>00447 
<a name="l00448"></a>00448         <span class="keywordtype">bool</span> *first(&amp;matrix_reachability[0][0]);
<a name="l00449"></a>00449         <a class="code" href="namespacegenevalmag.html#a311f0385029ff37574bbf0189064f310">warshall_algorithm</a>(cant_non_terminal, first);
<a name="l00450"></a>00450 
<a name="l00451"></a>00451         <span class="comment">/* Index of initial symbol of AG. */</span>
<a name="l00452"></a>00452         <span class="keywordtype">int</span> index_init(<a class="code" href="namespacegenevalmag.html#a6442b82b3f1265663c5bdb2bc80f4421">get_index</a>(init_symbol-&gt;<a class="code" href="classgenevalmag_1_1Symbol.html#afcd9c46fe546ec9f1b62caeb99377917">get_name</a>(),non_term));
<a name="l00453"></a>00453 
<a name="l00454"></a>00454         <span class="comment">/* Initialization the initial symbol. */</span>
<a name="l00455"></a>00455         matrix_reachability[index_init][index_init] = <span class="keyword">true</span>;
<a name="l00456"></a>00456         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j(0); j &lt; cant_non_terminal; j++)
<a name="l00457"></a>00457         {
<a name="l00458"></a>00458                 <span class="keywordflow">if</span>(!matrix_reachability[index_init][j])
<a name="l00459"></a>00459                 {
<a name="l00460"></a>00460                         cerr &lt;&lt; <span class="stringliteral">&quot;WARNING: Symbol Non-Teminal \&quot;&quot;</span>&lt;&lt; non_term[j] &lt;&lt; <span class="stringliteral">&quot;\&quot; unreachable.&quot;</span> &lt;&lt; endl;
<a name="l00461"></a>00461                 }
<a name="l00462"></a>00462         }
<a name="l00463"></a>00463         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00464"></a>00464 }
<a name="l00465"></a>00465 
<a name="l00469"></a><a class="code" href="namespacegenevalmag.html#ad0ec9b7706a340d2e674f3b4859afa2d">00469</a> <span class="keywordtype">bool</span> <a class="code" href="namespacegenevalmag.html#ad0ec9b7706a340d2e674f3b4859afa2d">check_eq_defines_it</a>(<span class="keyword">const</span> <a class="code" href="classgenevalmag_1_1Symbol.html">Symbol</a> *symb, <span class="keyword">const</span> <span class="keywordtype">int</span> index, <span class="keyword">const</span> <a class="code" href="classgenevalmag_1_1Attribute.html">Attribute</a> *attr, <span class="keyword">const</span> map&lt;unsigned short, Equation&gt; eqs)
<a name="l00470"></a>00470 {
<a name="l00471"></a>00471         <span class="keywordflow">for</span> (map&lt;unsigned short,Equation&gt;::const_iterator it_eq(eqs.begin()); it_eq != eqs.end(); it_eq++)
<a name="l00472"></a>00472         {
<a name="l00473"></a>00473                 <span class="keywordflow">if</span> (symb-&gt;<a class="code" href="classgenevalmag_1_1Symbol.html#a17e303be01f4c9cd3c1b167179d6e0aa">equals</a>(*it_eq-&gt;second.get_l_value()-&gt;get_symb()) &amp;&amp;
<a name="l00474"></a>00474                         index == it_eq-&gt;second.get_l_value()-&gt;get_num() &amp;&amp;
<a name="l00475"></a>00475                         attr-&gt;<a class="code" href="classgenevalmag_1_1Attribute.html#a1fa5839094c3ea82c49d1ee6319344ae">equals</a>(*it_eq-&gt;second.get_l_value()-&gt;get_attr()))
<a name="l00476"></a>00476                 {
<a name="l00477"></a>00477                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00478"></a>00478                 }
<a name="l00479"></a>00479         }
<a name="l00480"></a>00480         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00481"></a>00481 }
<a name="l00482"></a>00482 
<a name="l00487"></a><a class="code" href="classgenevalmag_1_1Semantics__checks.html#a7234750d25c375989dfc9318e081571d">00487</a> <span class="keywordtype">bool</span> <a class="code" href="classgenevalmag_1_1Semantics__checks.html#a7234750d25c375989dfc9318e081571d">Semantics_checks::check_well_defined_AG</a>(<span class="keyword">const</span> map &lt;unsigned short, Rule&gt; &amp;rules)
<a name="l00488"></a>00488 {
<a name="l00489"></a>00489         <span class="keywordflow">for</span> (map&lt;unsigned short, Rule&gt;::const_iterator it_r(rules.begin()); it_r != rules.end(); it_r++)
<a name="l00490"></a>00490         {
<a name="l00491"></a>00491                 <span class="comment">/* Get left Symbol. */</span>
<a name="l00492"></a>00492                 <span class="keyword">const</span> <a class="code" href="classgenevalmag_1_1Symbol.html">Symbol</a> *symb(it_r-&gt;second.get_left_symbol());
<a name="l00493"></a>00493 
<a name="l00494"></a>00494                 <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i(0); i &lt; symb-&gt;get_attrs().size(); i++)
<a name="l00495"></a>00495                 {
<a name="l00496"></a>00496                         <span class="keyword">const</span> <a class="code" href="classgenevalmag_1_1Attribute.html">Attribute</a> *attr_syn(symb-&gt;get_attrs()[i]);
<a name="l00497"></a>00497 
<a name="l00498"></a>00498                         <span class="keywordtype">bool</span> defined(<a class="code" href="namespacegenevalmag.html#ad0ec9b7706a340d2e674f3b4859afa2d">check_eq_defines_it</a>(symb, 0, attr_syn, it_r-&gt;second.get_eqs()));
<a name="l00499"></a>00499 
<a name="l00500"></a>00500                         <span class="keywordflow">if</span> (attr_syn-&gt;is_synthetize() &amp;&amp; !defined)
<a name="l00501"></a>00501                         <span class="comment">/* The attribute is synthetized. Must be defined. */</span>
<a name="l00502"></a>00502                         {
<a name="l00503"></a>00503                                 cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: \&quot;&quot;</span> &lt;&lt; symb-&gt;get_name() &lt;&lt; <span class="stringliteral">&quot;[&quot;</span>&lt;&lt; 0 &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>&lt;&lt; attr_syn-&gt;get_name() &lt;&lt; <span class="stringliteral">&quot;\&quot; type synthetized, haven&#39;t an equation that defines it.&quot;</span> &lt;&lt; endl;
<a name="l00504"></a>00504                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00505"></a>00505                         }
<a name="l00506"></a>00506                         <span class="keywordflow">if</span> (attr_syn-&gt;is_inherit() &amp;&amp; defined)
<a name="l00507"></a>00507                         <span class="comment">/* The attribute is inherit. Mustn&#39;t be defined. */</span>
<a name="l00508"></a>00508                         {
<a name="l00509"></a>00509                                 cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: \&quot;&quot;</span> &lt;&lt; symb-&gt;get_name() &lt;&lt; <span class="stringliteral">&quot;[&quot;</span>&lt;&lt; 0 &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>&lt;&lt; attr_syn-&gt;get_name() &lt;&lt; <span class="stringliteral">&quot;\&quot; type inherited, is defined outside his scope.&quot;</span> &lt;&lt; endl;
<a name="l00510"></a>00510                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00511"></a>00511                         }
<a name="l00512"></a>00512                 }
<a name="l00513"></a>00513 
<a name="l00514"></a>00514                 <span class="comment">/* Contains the symbols marked.s */</span>
<a name="l00515"></a>00515                 map&lt;string,const Symbol*&gt; marked_symbols;
<a name="l00516"></a>00516 
<a name="l00517"></a>00517                 <span class="comment">/* Cover the right symbols. */</span>
<a name="l00518"></a>00518                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i(0); i &lt; it_r-&gt;second.get_right_side().size(); i++)
<a name="l00519"></a>00519                 {
<a name="l00520"></a>00520                         symb = it_r-&gt;second.get_right_side()[i];
<a name="l00521"></a>00521                         <span class="keywordflow">if</span> (symb-&gt;is_non_terminal())
<a name="l00522"></a>00522                         {
<a name="l00523"></a>00523                                 pair&lt;string,const Symbol*&gt; new_p(symb-&gt;get_name(), symb);
<a name="l00524"></a>00524                                 pair&lt;map&lt;string,const Symbol*&gt;::iterator, <span class="keywordtype">bool</span>&gt; not_cheched(marked_symbols.insert(new_p));
<a name="l00525"></a>00525 
<a name="l00526"></a>00526                                 <span class="keywordflow">if</span>(not_cheched.second)
<a name="l00527"></a>00527                                 {
<a name="l00528"></a>00528                                         <span class="keywordtype">int</span> max_instance(it_r-&gt;second.count_non_terminal(symb));
<a name="l00529"></a>00529 
<a name="l00530"></a>00530                                         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j(0); j &lt; max_instance; j++)
<a name="l00531"></a>00531                                         {
<a name="l00532"></a>00532                                                 <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> k(0); k &lt; symb-&gt;get_attrs().size(); k++)
<a name="l00533"></a>00533                                                 {
<a name="l00534"></a>00534                                                         <span class="keywordflow">if</span>(symb-&gt;equals(*it_r-&gt;second.get_left_symbol()))
<a name="l00535"></a>00535                                                         {
<a name="l00536"></a>00536                                                                 <span class="keywordflow">continue</span>;
<a name="l00537"></a>00537                                                         }
<a name="l00538"></a>00538 
<a name="l00539"></a>00539                                                         <span class="keyword">const</span> <a class="code" href="classgenevalmag_1_1Attribute.html">Attribute</a> *attr(symb-&gt;get_attrs()[k]);
<a name="l00540"></a>00540 
<a name="l00541"></a>00541                                                         <span class="keywordtype">bool</span> defined(<a class="code" href="namespacegenevalmag.html#ad0ec9b7706a340d2e674f3b4859afa2d">check_eq_defines_it</a>(symb, j, attr, it_r-&gt;second.get_eqs()));
<a name="l00542"></a>00542 
<a name="l00543"></a>00543                                                         <span class="keywordflow">if</span> (attr-&gt;is_inherit() &amp;&amp; !defined)
<a name="l00544"></a>00544                                                         {
<a name="l00545"></a>00545                                                                 cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: \&quot;&quot;</span> &lt;&lt; symb-&gt;get_name() &lt;&lt; <span class="stringliteral">&quot;[&quot;</span>&lt;&lt; j &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>&lt;&lt; attr-&gt;get_name() &lt;&lt; <span class="stringliteral">&quot;\&quot; type inherited, haven&#39;t an equation that defines it.&quot;</span> &lt;&lt; endl;
<a name="l00546"></a>00546                                                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00547"></a>00547                                                         }
<a name="l00548"></a>00548                                                         <span class="keywordflow">if</span> (attr-&gt;is_synthetize() &amp;&amp; defined)
<a name="l00549"></a>00549                                                         {
<a name="l00550"></a>00550                                                                 cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: \&quot;&quot;</span> &lt;&lt; symb-&gt;get_name() &lt;&lt; <span class="stringliteral">&quot;[&quot;</span>&lt;&lt; j &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>&lt;&lt; attr-&gt;get_name() &lt;&lt; <span class="stringliteral">&quot;\&quot; type synthetized, is defined outside his scope.&quot;</span> &lt;&lt; endl;
<a name="l00551"></a>00551                                                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00552"></a>00552                                                         }
<a name="l00553"></a>00553                                                 }
<a name="l00554"></a>00554                                         }
<a name="l00555"></a>00555                                 }
<a name="l00556"></a>00556                         }
<a name="l00557"></a>00557                 }
<a name="l00558"></a>00558         }
<a name="l00559"></a>00559         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00560"></a>00560 }
<a name="l00561"></a>00561 
<a name="l00562"></a>00562 } <span class="comment">/* end genevalmag */</span>
</pre></div></div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Sat Sep 4 15:19:12 2010 for maggen by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
