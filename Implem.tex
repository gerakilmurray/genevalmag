\chapter{Detalles de Implementación de \maggen}
\label{chap:implem}
\minitoc

En esta sección se aclararan y expondrán decisiones que se realizaron a lo largo de la implementación de esta herramienta.

Primero, como ya se menciona en el capítulo anterior, el lenguaje sobre el cual se realizó el desarrollo de \maggen es C++, con lo que todo el código es principalmente característico de un modelo de programación Orientado a Objetos, aunque posee secciones de Programación Imperativa, para lograr ciertas optimizaciones y poder integrar componentes de externos a la herramienta.

\section{Parsing usando \boost\ \spirit}

El primer desafío de codificación, fue que se debía conseguir parsear el archivo de entrada de la herramienta, en el cual vendría la especificación de una Gramática de Atributos, respetando la sintaxis presentada anteriormente, o no.

La solución obtenida se apoya en la utilización de un framework reconocido mundialmente, denominado \spirit, perteneciente a la biblioteca de C++ llamada \boost. Esta decisión trajo dos grandes beneficios; la confiabilidad de el parser obtenido y la rápida obtención del mismo, ya que la gran ventaja de \spirit, es que permite escribir la definición de la gramática en lenguaje \textbf{C++}.

\spirit\ es un framework generador de analizadores sintácticos, o parsers, descendentes recursivos orientado a objetos implementado usando técnicas de meta-programación con plantillas. Las expresiones mediante plantillas, permiten aproximar la sintaxis de una ``\textit{\textit{Forma Backus Normal Extendida}}'' (\textbf{EBNF}) completamente en C++.

Se puede resumir que el proceso de análisis sintáctico, en este framework, se componente de cuatro partes.

\begin{figure}\centering
\includegraphics[width=400pt, height=172pt]{./spirit.png}
\caption{Procesos dentro de \spirit}\label{procesoSpirit}
\end{figure}

El usuario es el responsable de definir las ``\texttt{semantic actions}'' para lograr capturar los resultados intermedios, producidos durante la etapa de parsing y no sólo obtener un valor lógico sobre si se pudo o no, consumir toda la cadena de entrada.

Para comenzar a definir una gramática hay que crear una estructura que herede de la clase \texttt{grammar}. Dentro de ella se debe definir a su vez otra estructura templatizada denominada \texttt{definition}. En donde realmente estará la definición de la gramática.

\begin{lstlisting}[language=C++, basicstyle=\scriptsize,numbers=left, numbersep=5pt, numberstyle=\tiny]
struct my_grammar: public grammar <my_grammar>
{
    template <typename ScannerT>
    struct definition
    {
        rule <ScannerT> r;

        definition(my_grammar const& self)
        {
            r = /*... Aqui va la definicion ...*/;
        }

        rule <ScannerT> const& start() const
        {
            return r;
        }
    };
};
\end{lstlisting}

Para definirla, disponemos de un amplio conjunto de herramientas. Primero, los operadores de metalenguaje listados en la tabla \ref{ope_spirit}, los cuales permiten construir nuevas reglas combinando reglas ya definidas, parsers y constantes permitidas en el framework.

\begin{figure}\centering\scriptsize
\begin{tabular}{| c | p{7cm} |}
\hline
\multicolumn{1}{|>{\columncolor[rgb]{0.8, 0.8, 0.8}}l|}{\textbf{Operador}} &
\multicolumn{1}{|>{\columncolor[rgb]{0.8, 0.8, 0.8}}l|}{\textbf{Semántica}} \\ \hline
A $=$                  B  & Definición de A en base a B \\ \hline
A $|$                  B  & Unión, acepta A o B, también llamada ``alternativa''\\ \hline
A $\&$                 B  & Intersección, acepta A y B \\ \hline
A $-$                  B  & Diferencia, acepta A pero no a B  \\ \hline
A $\textasciicircum$   B  & Disyunción exclusiva, acepta A o B, pero no a ambos \\ \hline
A $>>$                 B  & Secuencia, acepta A seguido de B \\ \hline
\multirow{2}{*}{A $\%$ B} & Lista, acepta A separados por ocurrencias de B.\\
                          & Es equivalente a: A $>>$ *(B $>>$ A)\\ \hline
$*$                    A  & Estrella de Kleene, 0 o más veces \\ \hline
$+$                    A  & Positivo, 1 o más veces \\ \hline
$!$                    A  & Opcional, 0 o 1 vez \\ \hline
\end{tabular}
\caption{Operadores de \spirit\ utilizados}\label{ope_spirit}
\end{figure}

Por otra parte, \spirit\ dispone de un gran conjunto de parsers que abarcan la mayoría de los tipos básicos, representación de datos y valores utilizados en el común de los lenguajes (ver tabla \ref{parsers}).

\begin{figure}\centering\scriptsize
\begin{tabular}{| l | l |}
\hline
\multicolumn{1}{|>{\columncolor[rgb]{0.8, 0.8, 0.8}}l|}{\textbf{Parser}} &
\multicolumn{1}{|>{\columncolor[rgb]{0.8, 0.8, 0.8}}l|}{\textbf{Entrada aceptada}} \\ \hline
anychar\_p & Cualquier carácter simple (incluyendo el carácter nulo: '$\setminus0$')\\ \hline
alnum\_p   & Caracteres alfa-numéricos \\ \hline
alpha\_p   & Caracteres alfabéticos \\ \hline
% blank\_p & Un espacio o tabulación \\ \hline
digit\_p   & Dígitos numéricos \\ \hline
lower\_p   & Caracteres en minúscula \\ \hline
upper\_p   & Caracteres en mayúscula \\ \hline
space\_p   & Espacios, tabulaciones, saltos de línea y nuevas líneas \\ \hline
ch\_p      & Carácter especificado como parámetro \\ \hline
str\_p     & Cadena especificada como parámetro \\ \hline
oct\_p     & Dígito en octal \\ \hline
hex\_p     & Dígito en hexadecimal \\ \hline
uint\_p    & Número entero sin signo de 32 bits\\ \hline
int\_p     & Número entero 32 bits\\ \hline
real\_p    & Número flotante 32 bits\\ \hline
eps\_p     & Cadena vacía (épsilon)\\ \hline
end\_p     & Carácter de fin de archivo (EOF)\\ \hline
\end{tabular}
\caption{\label{parsers}Parsers predefinidos de \spirit\ utilizados} 
\end{figure}

Además posee varias directivas que modifican el comportamiento de los parsers, encapsulándose en una expresión definida por el usuario (ver tabla \ref{directivas}).

\begin{figure}\centering\scriptsize
\begin{tabular}{| l | p{7cm} |}
\hline
\multicolumn{1}{|>{\columncolor[rgb]{0.8, 0.8, 0.8}}l|}{\textbf{Directiva}} &
\multicolumn{1}{|>{\columncolor[rgb]{0.8, 0.8, 0.8}}l|}{\textbf{Efecto}} \\ \hline
lexeme\_d    & Deshabilita la omisión de espacios en blanco (space\_p)\\ \hline
as\_lower\_d & Convierte en minúscula lo aceptado por la expresión\\ \hline
\multirow{3}{*}{longest\_d} & Deshabilita el corto circuito, manda al analizador que\\
                            & pruebe todas las alternativas posibles y elija la secuen-\\
                            & cia más larga aceptada \\ \hline
\end{tabular}
\caption{\label{directivas}Directivas de \spirit\ aplicadas}
\end{figure}

Para el manejo de los símbolos válidos dentro de la definición de la gramática, \spirit\ soporta nativamente, el concepto de ``Tablas de símbolos''. Lo que permite registrar de manera dinámica nuevos símbolos, en particular dentro de nuestra herramienta nos ayudó a manejar los conjuntos de nombres válidos para los \texttt{sorts}, los símbolos no terminales permitidos en las ecuaciones, entre otros usos.

\vspace{1cm}

\begin{lstlisting}[language=C++, basicstyle=\scriptsize,numbers=left, numbersep=5pt, numberstyle=\tiny]
/*
 * Symbols's Table for the elements of an Attribute Grammar.
 */
symbols <> st_sorts;
symbols <> st_op_prefix;
symbols <> st_op_infix;
symbols <> st_op_postfix;
symbols <> st_functions;
symbols <> st_attributes;
symbols <> st_non_terminal;
\end{lstlisting}

Para comenzar a interactuar con el framework, el usuario debe declarar un objeto de la estructura definida y pasarlo como parámetro a una función específica de \spirit.

\begin{lstlisting}[language=C++, basicstyle=\scriptsize, numbers=left, numbersep=5pt, numberstyle=\tiny]
my_grammar g;

if (parse(first, last, g, space_p).full)
{
    cout << "Parsing Succeeded\n";
}
else
{
    cout << "Parsing Failed\n";
}
\end{lstlisting}

Lo primero que se tuvo que realizar, fue definir los componentes básicos que se iban a necesitar para construir las demás declaraciones.

\begin{description}
\item [Identificadores] son los nombres de sorts, funciones, atributos, símbolos no terminales y reglas, permitidos por \maggen\ y se basan en el común de los estándares. Debido a que el lenguaje del evaluador generado es C++, todas las palabras reservadas de ese lenguaje, son de la misma clase para nuestra herramienta.

\begin{lstlisting}[language=C++, basicstyle=\scriptsize, numbers=left, numbersep=5pt, numberstyle=\tiny]
r_ident = lexeme_d[(alpha_p|'_')>>*(alnum_p|'_')]-r_reserved_word;

r_reserved_word = str_p("compute")|"end"
                | "all"
                | "semantic domain"|"attributes" |"rules"
                | "sort"|"op"|"function"
                | "infix"|"prefix"|"postfix"
                | "syn"|"inh"
                | "left"|"right"|"non-assoc"
                | r_cpp_reserved_words
                ;

r_cpp_reserved_words = r_cpp_basic_types
                     | str_p("and")|"and_eq"|"asm"|"auto"|"bitand"
                     | "bitor"|"break"|"case"|"catch"|"class"|"compl"
                     | "const"|"const_cast"|"continue"|"default"
                     | "delete"|"do"|"double"|"dynamic_cast"|"else"
                     | "enum"|"explicit"|"export"|"extern"|"false"
                     | "for"|"friend"|"goto"|"if"|"inline"|"long"
                     | "mutable"|"namespace"|"new"|"not"|"not_eq"
                     | "operator"|"or"|"or_eq"|"private"|"protected"
                     | "public"|"register"|"reinterpret_cast"|"return"
                     | "short"|"signed"|"sizeof"|"static"|"static_cast"
                     | "struct"|"switch"|"template"|"this"|"throw"|"true"
                     | "try"|"typedef"|"typeid"|"typename"|"union"
                     | "unsigned"|"using"|"virtual"|"void"|"volatile"
                     | "wchar_t"|"while"|"xor"|"xor_eq"
                     ;

r_cpp_basic_types = str_p("bool")|"char"|"float"|"int"|"string";
\end{lstlisting}

\item [Operadores] Dentro de la especificación de la GA, se permiten como nombre válidos para los operadores, caracteres alfabéticos, numéricos y los operadores básicos de C++. 

\begin{lstlisting}[language=C++, basicstyle=\scriptsize, numbers=left, numbersep=5pt, numberstyle=\tiny]
r_oper = lexeme_d[(alpha_p|'_'|r_id_op)>>*(alnum_p|'_'|r_id_op)];

r_id_op = ch_p('+')|'*'|'/'|'^'|'%'|'&'|'<'|'='|'-'|'>'|'|'|'~'|'.'|','|'?';
\end{lstlisting}

\item [Literales] Son los valores de constantes y tipos básicos aceptados, se adecuan a los estándares de C++. Solamente se tuvo que definir los valores lógicos, los caracteres entre comillas simples y las cadenas de caracteres entre comillas dobles, ya que para los tipos numéricos, existen parsers predefinidos de \spirit\ como ya se dio a conocer.

\begin{lstlisting}[language=C++, basicstyle=\scriptsize, numbers=left, numbersep=5pt, numberstyle=\tiny]
r_boolean = str_p("true")|"false";

r_char = lexeme_d[ch_p('\'')>>(anychar_p)>>ch_p('\'')];

r_string = lexeme_d[ch_p('\"')>>r_string_lit>>ch_p('\"')];

r_string_lit = +((anychar_p-(ch_p('\"')|"\\"|'\'' ))|r_esc_seq);

r_esc_seq = ch_p('\\')>>
            ( oct_p
            | as_lower_d['x']>>hex_p
            | (anychar_p-ch_p('\n'))
            );               
\end{lstlisting}
\end{description}

\subsection{\texttt{``semantic domain''} en \spirit}

En esta sección de la especificación se debían aceptar tres tipos de elementos: \texttt{sorts}, \texttt{operators} y \texttt{functions}.

Los \texttt{sorts} serán los tipos que se podrán utilizar para definir los dominios e imágenes de los operadores y funciones.

Según lo explicado en el Diseño, las reglas de cada clase, han sido codificados de la siguiente manera.

\begin{description}
\item [\texttt{sorts}] Exigimos que luego del identificador ``\texttt{sort}'' halla un espacio\footnote{Ver definición de space\_p \ref{parsers}}. El nombre leído, se usará para crear un nuevo Sort dentro de la GA y también se insertará en la tabla de símbolos de sorts. Se acepta una lista de nombres de sorts para comodidad del usuario.

\begin{lstlisting}[language=C++, basicstyle=\scriptsize, numbers=left, numbersep=5pt, numberstyle=\tiny]
/* Declaration of Sorts. */

r_decl_sort = lexeme_d[str_p("sort")>>space_p]>>
              (r_ident[&create_sort][st_sorts.add]%',')>>
              ';';
\end{lstlisting}

\item [\texttt{operators}] Para los operadores también se exige el espacio. Por definición se aceptan tres tipos: infijos, prefijos y posfijos, por lo que se hizo una regla para cada uno, solamente discriminado los dominios, ya que todos poseen una sóla imagen. Notar que los sorts permitidos, son sacados directamente de las tablas de símbolos destinadas para ese propósito.

\begin{lstlisting}[language=C++, basicstyle=\scriptsize, numbers=left, numbersep=5pt, numberstyle=\tiny]
/* Declaration of Operators. */

r_decl_oper  = lexeme_d[str_p("op")>>space_p][&inic_func]>>
               (r_oper_infix|r_oper_postfix|r_oper_prefix)>>
               str_p("->")>>
               r_sort_st[&save_image_func]>>
               ';';

r_oper_infix = str_p("infix")[&save_mode_op]>>
               !r_oper_mode>>
               r_oper[&save_name_func][st_op_infix.add]>>
               ':'>>
               r_sort_st[&save_domain_func]>>','>>r_sort_st[&save_domain_func];

r_oper_postfix = str_p("postfix")[&save_mode_op]>>
                 !r_oper_mode>>
                 r_oper[&save_name_func][st_op_postfix.add]>>
                 ':'>>
                 r_sort_st[&save_domain_func];

r_oper_prefix = !(str_p("prefix")[&save_mode_op])>>
                !r_oper_mode>>
                r_oper[&save_name_func][st_op_prefix.add]>>
                ':'>>
                r_sort_st[&save_domain_func];

r_oper_mode = '('>>
               (uint_p[&save_prec_op]|'_')>>
               ','>>
               (r_oper_assoc[&save_assoc_op]|'_')>>
               ')';

r_oper_assoc = str_p("left")|"right"|"non-assoc";
\end{lstlisting}

\item [\texttt{functions}] Para las funciones se permiten como dominio listas de sorts, los cuales serán agregados incrementalmente a la función que se está declarando. La utilización de acciones semánticas facilitan la modularización.

\begin{lstlisting}[language=C++, basicstyle=\scriptsize, numbers=left, numbersep=5pt, numberstyle=\tiny]
/* Declaration of Functions. */

r_decl_func = lexeme_d[str_p("function")>>space_p]>>
              r_oper[&inic_func][&save_name_func][st_functions.add]>>
              ':'>>
              !r_dom_func>>
              str_p("->")>>
              r_sort_st[&save_image_func]>>
              ';';

r_dom_func = r_sort_st[&save_domain_func]%',';
\end{lstlisting}
\end{description}

\subsection{\texttt{``attributes''} en \spirit }

Para la codificación de esta sección la funcionalidad buscada era que el usuario mediante una expresión en términos de conjuntos definiera la pertenencia de cada atributo. Por lo que se tuvo que implementar un ``mini-intérprete'' sobre expresiones de conjuntos.

Un detalle a tener en cuenta, en este punto, es que no se encuentra declarado ningún ``Símbolo No Terminal'', así que todo símbolo mencionado dentro de la expresión será creado bajo demanda.

La vinculación de los atributos con sus respectivos dueños, se realizará más adelante, debido a que existe la posibilidad de declarar un atributo para todo símbolo, mediante la sentencia \texttt{all}, antes de tener totalmente definido el conjunto de símbolos no terminales de la gramática.

\begin{lstlisting}[language=C++, basicstyle=\scriptsize, numbers=left, numbersep=5pt, numberstyle=\tiny]
/*
 * Declaration of Attributes.
 */
r_attributes = lexeme_d[str_p("attributes")>>space_p]>>
               +r_decl_attr[&create_attributes];

r_decl_attr = (r_ident[&add_attribute][st_attributes.add]%',')>>
              ':'>>
              !(r_type_attr[&save_type_attr])>>
              '<'>>r_sort_st[&save_sort_attr]>>'>'>>
              lexeme_d[str_p("of")>>space_p]>>
              (r_conj_symb |
               (str_p("all")>>!('-'>>r_conj_symb))
              )[&save_member_list_attr]>>
              ';';

r_conj_symb = '{'>>(r_ident%',')>>'}';

r_type_attr = str_p("inh")|"syn";
\end{lstlisting}

\subsection{\texttt{``rules''} en \spirit}

En la definición de una gramática las reglas son los pilares, por eso en esta sección se debía brindar la mayor flexibilidad al usuario.

El bloque de reglas comienza con el identificador ``\texttt{rules}'', mediante un espacio de por medio, la lista  de reglas. Cada una de las mismas son enumeradas desde 1 para mantener una indexación interna. Una vez consumido el bloque se realizan los chequeos que determinan si la GA es MAG o no.

\begin{lstlisting}[language=C++, basicstyle=\scriptsize, numbers=left, numbersep=5pt, numberstyle=\tiny]
/*
 * Declaration of Rules.
 */
r_rules = lexeme_d[str_p("rules")>>space_p]>>
          (+r_decl_rule)>>eps_p[&check_well_defined];
\end{lstlisting}

Una regla individualmente esta representada por un identificador y los caracteres ``\texttt{::=}'' y una lista de símbolos, dejando también la posibilidad de escribir reglas abreviadas mediante el uso del operador ``|'' junto a una nueva lista de símbolos, evitando repetir el lado izquierdo de la regla.

\begin{lstlisting}[language=C++, basicstyle=\scriptsize, numbers=left, numbersep=5pt, numberstyle=\tiny]
r_decl_rule = r_ident[&create_new_non_terminal][&create_rule][st_non_terminal.add]>>
              str_p("::=")>>
              r_right_rule[&save_rule]>>
              *(str_p("|")[&create_abbreviated_rule]>>
              r_right_rule[&save_rule])>>
              ';';
\end{lstlisting}

Dentro de la lista de símbolos se aceptan identificadores de símbolos no terminales y símbolos terminales, definidos mediante una regla específica. Ambos, son creados controlando que no existan repetidos, actualizando la tabla de símbolos solamente de los no terminales.

Se consideran símbolos terminales a cualquier cadena de caracteres encerrada entre comillas simples.

Por definición, una regla puede no contener un bloque de ecuaciones, por lo que es opcional.

\begin{lstlisting}[language=C++, basicstyle=\scriptsize, numbers=left, numbersep=5pt, numberstyle=\tiny]
r_right_rule = +( r_ident[&create_new_non_terminal][st_non_terminal.add]
                | r_terminal[&create_new_terminal]
                )[&save_right_side_rule]>>
               !r_compute_eq;

r_terminal = lexeme_d[ch_p('\'')>>r_string_lit>>ch_p('\'')];
\end{lstlisting}

El mismo estará delimitado por las cadenas \texttt{``compute}'' y \texttt{``end}'', en su interior se aceptará una lista con al menos \textbf{una} ecuación. Las cuales están compuestas por una instancia de atributo, como ``\texttt{l-value}'', el carácter ``\texttt{=}'' y una expresión como ``\texttt{r-value}''.

\begin{lstlisting}[language=C++, basicstyle=\scriptsize, numbers=left, numbersep=5pt, numberstyle=\tiny]
r_compute_eq = str_p("compute")>>
               +(r_equation)>>
               str_p("end");

r_equation = r_instance[&create_equation]>>
             '='>>
             r_expression[&save_rvalue]>>
             ';';
\end{lstlisting}

Las expresiones aceptadas por la herramienta, pueden ser de cualquier tipo, es decir, se utilizó la gramática de expresiones ambigüas que figura en la mayoría de los libros sobre este tema.

\begin{lstlisting}[backgroundcolor=\color{white}]
E := E op E
   | (E)
   | literal
\end{lstlisting}

Donde ``op'' se interpreta como cualquier operador. Esta gramática presentaba el problema de la ``recursión a izquierda'', por lo que se la quitó obteniendo lo siguiente.

\begin{lstlisting}[backgroundcolor=\color{white}]
E := T op1 E
   | T

T := F op2 T
   | F

F := (E)
   | literal
\end{lstlisting}

En nuestra especificación, los ``literales'' pueden ser solamente tres cosas: funciones, instancias de atributos y los literales propiamente dichos (caracteres, cadenas, valores lógicos, números enteros y flotantes). Los operadores fueron discriminados puntualmente según su sintaxis.

Además, debido a una restricción de \spirit, se tuvo que reescribir toda regla de la forma:

\begin{center}\textbf{\large{$ A := B A | B  \Rightarrow  A := B (A)* $}}\end{center}

Logrando la siguiente gramática de expresiones, que luego fue codificada en \spirit.

\begin{lstlisting}[backgroundcolor=\color{white}]
E := T (op_infix E)*

T := F (op_postfix)*
   | op_prefix T

F := (E)
   | function
   | literal
   | instance

literal := real
         | int
         | char
         | string
         | bool
\end{lstlisting}


\subsection*{Observaciones}

Toda la implementación del analizador sintáctico de \maggen\ está dentro del directorio ``Parser'', en el que se encuentran los siguientes archivos:

\begin{description}
\item [Parser.cpp] baba
\item [Semantics\_actions.cpp] bebe
\item [Semantics\_checks.cpp] bubu
\end{description}

\section{Algoritmo de generación de secuencia de visita}

bla bla
\section{Algoritmo de generación de código}
bla bla
