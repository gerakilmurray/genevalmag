\chapter{Diseño de \maggen}
\label{chap:disen_}
\minitoc

\section{Lenguaje de especificación de las MAG}
\label{sec:lenguajeMAG}

El lenguaje de especificación utilizado para la descripción de una Gramática de atributos (MAG) fue definido en el marco de este proyecto. Esto permite definir una gramática de atributos como input de \maggen.
 
La secciones que conforman la descripción de una gramática de atributos se corresponden con las características que definen a una gramática de atributos como tal (ver capítulo de GA).
 
Informalmente, el lenguaje de especificación se conforma de las siguientes partes:

\begin{description}
\item [Bloque Dominio Semántico] Destinando a la declaración de sort, operadores y funciones que se utilizarán en los otros dos bloques. Este bloque es denominado ``\texttt{semantic domain}''.

\item [Bloque de Atributos] Destinando a la declaración y definición de los atributos asociados a cada símbolo. Este bloque es denominado ``\texttt{attributes}''.

\item [Bloque de Reglas] Destinado a la declaración y definición de las reglas sintácticas de la gramática con sus correspondientes ecuaciones semánticas para cada atributo asociado a cada símbolo. Este bloque es denominado ``\texttt{rules}''.
\end{description}

A los tres bloques analizados anteriormente, podemos clasificarlos en dos, teniendo en cuenta su comportamiento o funcionalidad dentro de la especificación. Los dos primeros, son bloques puramente declarativos o dedicados a la definición de elementos que serán utilizados en el tercer bloque. Este bloque, es considerado el de mayor auge, ya que marca la sintaxis y semántica de la gramática.

Cada bloque del lenguaje de especificación contiene su sintaxis propia para su definición, es por ello que, en las secciones siguientes nos encargaremos de mostrar detalles de cada uno de ellos.

El análisis de cada bloque se realizará de una manera más formal y observando cada bloque como partes de una gramática.

Entonces, sea \textbf{G: CFG} que define el lenguaje de especificación para el archivo de entrada aceptado por \maggen. Se define la siguiente regla de \textbf{G: CFG} para el símbolo inicial ``S''.

\vspace{0.3cm}
\begin{lstlisting}[frame=shadowbox, rulesepcolor=\color{azul},language=specmag, linewidth=10cm ]
S = semantic domain decl_Sd
  | attributes decl_attrs
  | rules decl_rules
\end{lstlisting}
\vspace{0.3cm}

En las secciones siguientes se presentaran los símbolos \textit{decl\_Sd}, \textit{decl\_attr} y \textit{decl\_rules} con más detalle.  

\subsection{Bloque Dominio semántico}

El bloque ``\texttt{semantic domain}'' es el encargado de la definición de elementos que serán necesarios para los bloques siguientes. 

El bloque semántico esta subdividido en 3 secciones, que se corresponden con la definición de sort, operadores y funciones, cada una con su sintaxis propia. 

Entonces se define el símbolo \textit{decl\_Sd} como:

\vspace{0.3cm}
\begin{lstlisting}[frame=shadowbox, rulesepcolor=\color{azul},language=inform,linewidth=10cm]
decl_Sd = (decl_sort)*
        | (decl_operator)*
        | (decl_function)*
\end{lstlisting}
\vspace{0.3cm}

El uso de ``\texttt{*}'' (``0 o más veces'') en cada subsección y no de ``\texttt{+}'', esta dado, debido a que cada una de estas secciones son opcionales, es decir, no se obliga a la existencia de cada sección. Por ejemplo, podría interesar la definición de una gramática que no cuente con funciones.

La sintaxis particular de cada sección se analiza individualmente a continuación.

\subsubsection{Declaración de sort}
La subsección de ``\texttt{sort}'' declara todos los posibles tipos que serán necesarios para las declaraciones siguientes. Todo \texttt{sort} es distinguible en el lenguaje mediante un nombre.

A continuación se define el símbolo \texttt{decl\_sort}

\vspace{0.3cm}
\begin{lstlisting}[frame=shadowbox, rulesepcolor=\color{azul}, language=specmag, linewidth=10cm]
decl_sort = sort NAME_SORT  list_sort;

list_sort = , NAME_SORT list_sort
          | `$\lambda$`
\end{lstlisting}
\vspace{0.3cm}

\textit{``NAME\_SORT''} representa el nombre del sort o tipo. El mismo, se corresponde con la definición de un identificador en el común de los lenguajes de programación. Es decir, acepta caracteres alfanuméricos y guiones bajos, restringiendo a los caracteres numéricos como primer carácter, como también palabras reservadas definidas por la especificación (para mas detalles ver Apéndice \ref{append:grammarspirit} de implementación en \spirit).\\

\underline{Ejemplo:} \begin{center} \fbox{\texttt{\ sort int;\ }} \end{center}
\vspace{0.2cm}
Esta línea declara el tipo ``\texttt{int}''.

\subsubsection*{Tipos predefinidos por el lenguaje}
\label{sec:typepredefined}

El lenguaje de especificación contempla los siguiente tipos básicos:

\begin{description}
\item [int] Tipo entero de 32 bits.

\item [float] Tipo real en punto flotante de 32 bits.

\item [bool] Tiene en cuenta los valores \texttt{true} y \texttt{false}.

\item [char] Tipo char en el común de los lenguajes (encerrado entre comillas simples).

\item [string] Cadenas de caracteres (entre comillas dobles).
\end{description}

En caso de declaración explícita de cualquiera de ellos, en la especificación, la línea no es reflejada en el funcionamiento interno de \maggen.

\subsubsection{Declaración de operadores}
La sección destinada a la declaración de \texttt{operadores} acepta 3 tipos de operadores, los cuales, difieren en su forma de uso y cantidad de operandos. Denominados, infijo, prefijo y posfijo. 

La interpretación de cada uno, esta dada por la interpretación natural común a todos los lenguajes de programación, a modo de ejemplo se muestran un operador de cada tipo para evitar problemas en esta sección:

\begin{itemize}
\item \underline{Operador \texttt{prefijo}:} \textit{Ejemplo:} \textbf{-2}. Operador de menos unario. 

\item \underline{Operador \texttt{posfijo}:} \textit{Ejemplo:} \textbf{i++}. Operador de auto-incremento en lenguaje C y C++.

\item \underline{Operador \texttt{infijo}:} \textit{Ejemplo: \textbf{2 + 3}}. Operador ``suma''.
\end{itemize}

A continuación se define el símbolo \texttt{decl\_operator}:

\vspace{0.3cm}
\begin{lstlisting}[frame=shadowbox, rulesepcolor=\color{azul}, language=specmag ]
decl_operator = op infix  mode_op NAME_OP:
                NAME_SORT ,  NAME_SORT -> NAME_SORT;
              | op prefix mode_op NAME_OP:
                NAME_SORT -> NAME_SORT;
              | op postfix mode_op NAME_OP:
                NAME_SORT -> NAME_SORT;
              | op mode_op NAME_OP:
                NAME_SORT -> NAME_SORT;

mode_op = ( m_op )
        | `$\lambda$`

m_op    = NUM_PRECEDENCE , assoc
        | _ , assoc
        | NUM_PRECEDENCE , _
        | _ , _

assoc   = (left | right | non_assoc)
\end{lstlisting}
\vspace{0.3cm}

\textit{``NAME\_OP''} representa un identificador para el operador (infija, prefija y posfija). Las restricciones y detalles a tener en cuenta para este identificador son las mismas que se analizaron para ``NAME\_SORT''.

\textit{``NUN\_PRECEDENCE''} representa un número positivo que define la precedencia del operador. Cabe aclarar que a mayor número mayor la precedencia.

\subsubsection*{Consideraciones}

Es importante analizar el uso de ``\_'' para precedencia y asociatividad en el hecho de que estos datos son tomados opcionalmente, es decir se puede omitir dicha información. Lo mismo sucede con el tipo del operador (infijo, prefijo y posfijo). 

Para estos casos especiales se utilizarán los siguientes valores por defecto:

\begin{description}
\label{desc:default}
\item [Precedencia] = \texttt{USHRT\_MAX}.

\item [Asociatividad] = \texttt{left}.

\item [Tipo de operador] = \texttt{prefix}.
\end{description}

Otro caso a tener cuenta es el uso de \texttt{non\_assoc} como asociatividad del operador. Este caso define que el operador no tiene asociatividad, con lo que el uso del mismo en las ecuaciones debe respetar esta condición, en caso contrario se observará un error por mal uso.
\subsection*{Ejemplos}

\begin{enumerate}

\item 
\begin{center}
\fbox{\texttt{\ op infix (\_,right) *: int, int -> int;\ }}\end{center}
\vspace{0.2cm}
Esta línea declara el operador infijo ``\texttt{*}'' con precedencia por defecto y asociatividad \texttt{right}. Esta línea también podría haber sido definida como:
\vspace{0.2cm}
\begin{center}
\fbox{\texttt{\ op infix *: int, int -> int;\ }}\end{center}
\vspace{0.2cm}
donde se usan valores por defecto para precedencia y asociatividad.

\item 
\begin{center}
\fbox{\texttt{\ op prefix (60,non\_assoc) \%: int -> int;\ }}\end{center}
\vspace{0.2cm}
Esta línea declara el operador prefijo ``\texttt{\%}'' con precedencia \texttt{60} y asociatividad \texttt{non\_assoc}. Esta línea también podría haber sido definida como:
\vspace{0.2cm}

\begin{center}
\fbox{\texttt{\ op (60, non\_assoc) \%: int -> int;\ }}\end{center}
\vspace{0.2cm}
y en el caso que se desee usar valores de asociatividad y precedencia por defecto así:
\vspace{0.2cm}

\begin{center}
\fbox{\texttt{\ op \%: int -> int;\ }}\end{center}
\end{enumerate}
\subsubsection{Declaración de funciones}
La noción de funciones dentro de la especificación es tomada con la noción natural de función matemática. Es decir, toda función esta definida mediante un identificador, un dominio y una imagen.

Definimos \texttt{decl\_function} como:

\vspace{0.3cm}
\begin{lstlisting}[frame=shadowbox, rulesepcolor=\color{azul}, language=specmag]
decl_function = function NAME_FUNC: decl_domain -> NAME_SORT;

decl_domain = NAME_SORT, decl_domain
            | NAME_SORT
            | `$\lambda$`
\end{lstlisting}
\vspace{0.3cm}

\textit{``NAME\_FUNC''} define el identificador de la función, en el cual se asumen las mismas restricciones tomadas para los identificadores analizados en las secciones anteriores. Cabe aclarar que se acepta un dominio vacío lo que permite el uso de funciones que solo retornan un valor.

Es importante tener en cuenta que las funciones son tomadas con los valores por defecto de operador para asociatividad y precedencia \ref{desc:default}.\\

\underline{Ejemplo:}\ \begin{center}
\fbox{\texttt{\ function f:int, int, int, int -> real;\ }}                                                                           \end{center}
\vspace{0.2cm}
Esta línea declara la función ``\texttt{f}'' que tiene como entrada 4 elementos de tipo ``\texttt{int}'' y como salida un elemento de tipo ``\texttt{real}''.

\subsection{Bloque de Atributos}
En esta sección presentaremos el bloque ``attributes'' en detalle. La información que define un atributo dentro del lenguaje esta dado por: 

\begin{description}
\item [Nombre:] representa el nombre del atributo, el mismo respeta los requisitos de identificador analizados anteriormente.

\item [Clase de atributo:] está dado por la clase del atributo, esto es sintetizado (\texttt{syn}) o heredado (\texttt{inh}).

\item [Tipo:] está dado por el tipo del atributo. El mismo corresponde a un tipo básico (ver \ref{sec:typepredefined}) o a un sort definido en la sección de \textit{Sort}.

\item [Símbolos de pertenencia:] hace referencia a los símbolos a los cuales se asocia el atributo.
\end{description}

A continuación se define el símbolo \texttt{decl\_attrs} como:

\vspace{0.3cm}
\begin{lstlisting}[frame=shadowbox, rulesepcolor=\color{azul}, language=specmag]
decl_attrs = (d_attr)+

d_attr = NAME_ATTR : < c_attr > NAME_SORT of symbols;

symbols = { list_symbol }
        | all
        | all - { list_symbol }

c_attr = inh
       | syn
       | `$\lambda$`

list_symbol = SYMB_NON_TERMINAL , list_symbol
            | SYMB_NON_TERMINAL 
\end{lstlisting}
\vspace{0.3cm}

\textit{``NAME\_ATTR''} define el identificador de un atributo. Se tienen las mismas consideraciones que para el identificador de sort, operador y función.

\textit{``SYMB\_NON\_TERMINAL''} describe un símbolo no terminal de la gramática. En este punto se debe tener en cuenta que los símbolos utilizados deben ser símbolos no terminales utilizados en el bloque de reglas.

\textit{``NAME\_SORT''} declara el tipo del atributo, el mismo esta dado por un sort definido por el usuario o por un tipo predefinido por el lenguaje \ref{sec:typepredefined}.

\subsubsection*{Consideraciones}

\begin{itemize}
\item En la declaración de los símbolos a los cuales pertenece el atributos, ``\texttt{all}'' se interpreta como ``todos los símbolos'', es decir, el atributo declarado se asocia a todos los símbolos de la gramática. Además es posible utilizar el operado ``diferencia'' de conjuntos ``\texttt{-}'' para especificar el conjunto de símbolos a los cuales perteneces el atributo, como una expresión.

\item Si no se especifica la clase del atributo (sintetizado o heredado) el mismo es tomado como el caso por defecto a sintetizado.
\end{itemize}

\subsection*{Ejemplos}
\begin{enumerate}

\item 
\begin{center}
\fbox{\texttt{\ lex: syn <string>\ of all - {T};\ }}\end{center}
\vspace{0.2cm}
Se define el atributo ``\texttt{lex}'' sintetizado de tipo ``\texttt{string}'' para todos los símbolos excepto para el símbolo ``\texttt{T}''.

\item

\begin{center}
\fbox{\texttt{\ type: inh <string>\ of all;\ }}\end{center}
\vspace{0.2cm}
Se define el atributo ``\texttt{type}'' heredado de tipo ``\texttt{string}'' para todos los símbolos de la gramática.

\item 

\begin{center}
\fbox{\texttt{\ grade: <int>\ of {E, T};\ }}\end{center}
\vspace{0.2cm}
Se define el atributo ``\texttt{grade}'' sintetizado (por defecto) de tipo ``\texttt{int}'' para los símbolos ``\texttt{E}'' y ``\texttt{T}''.\\
\end{enumerate}

\subsection{Bloque de reglas}
Por último el bloque de reglas. La interpretación de las reglas dentro del lenguaje esta dada por la definición de gramática libre de contexto.          

El símbolo terminal se considera un símbolo entre comillas simples (\texttt{'}).\\ 

\underline{Ejemplo:}\ \fbox{\ \texttt{'literal'}\ }\\
\vspace{0.2cm}

Las ecuaciones describen las reglas semánticas que definen la sintaxis de la gramática. Cada ecuación define la interpretación semántica de los atributos de cada símbolo; esta definición se realiza mediante una expresión constituida por \textbf{instancias}, \textbf{literales} o aplicación de operadores y funciones a subexpresiones.
En este punto se deben tener en cuenta los requisitos necesarios de una gramática bien definida (Ver capítulo \ref{XXX}).

A continuación se define el símbolo \texttt{decl\_rules}:

\vspace{0.3cm}
\begin{lstlisting}[frame=shadowbox, rulesepcolor=\color{azul}, language=specmag]
decl_rules = (d_rule)+ 

d_rule = SYMB_NON_TERMINAL ::= rigft_symb decl_eqs

rigft_symb = (SYMB_NON_TERMINAL | SYMB_TERMINAL)+

decl_eqs = compute d_eqs end;
         | ;

d_eqs = instance = right_eq;

right_eq = leaf
         | leaf OP_NAME leaf right_eq
         | (OP_NAME)+ leaf
         | leaf (OP_NAME)+
         | NAME_FUNC ( right_eq ) 

leaf = instance
     | LITERAL

instance = SYMB_NON_TERMINAL[NUM_INS].NAME_ATTR
\end{lstlisting}
\vspace{0.3cm}

\textit{``SYMB\_NON\_TERMINAL''} y \textit{``SYMB\_TERMINAL''} describen símbolos no terminales y terminales respectivamente. En este punto, se tiene en cuenta la diferenciación entre estos tipos de símbolos como se analizó en el párrafo anterior.
 
\textit{``OP\_NAME''} y  \textit{``NAME\_FUNC''} describen identificadores de operadores infijos, prefijos y posfijos (según su uso) y el de función respectivamente. Tanto los operadores como las funciones se asumen definidos en la sección ``\texttt{semantic domain}''.

\textit{``NUM\_INS''} corresponde con un número mayor que cero que identifica la ocurrencia del símbolo (para mas detalle ver \ref{subsec:consirule} punto 4).

\textit{``LITERAL''} describe los tipos de literales entero, real, carácter, string y bool con las siguientes consideraciones:

\begin{description}
\item [Entero] es considerado un número entero de 32 bits. 
\item [Real] es considerado un número en punto flotante de 32 bits. La separación de decimales se da mediante el punto (.).
\item [Carácter] es considerado un carácter cualquiera entre comillas simples (').
\item [String] es considerado una cadena de caracteres entre comillas dobles (`` '').
\item [Bool] representa los valores \texttt{true} y \texttt{false}.
\end{description}

\subsubsection*{Consideraciones}
\label{subsec:consirule}
\begin{enumerate}
\item Es posible definir una regla de la gramática sin sección de ecuaciones, para ello se debe omitir la sección de ``\texttt{compute}'' en la definición. Si se define la sección de ``\texttt{compute}'' el lenguaje obliga a definir \textbf{al menos una ecuación}.

\item La sintaxis para el uso de los operadores esta dada por el tipo del operador: infijo, prefijo o posfijo. Para las funciones se utiliza la manera natural de invocación de una función en el común de los lenguajes de programación. Esto es, mediante el nombre de la función y los parámetros entre paréntesis.

\item La asociatividad y precedencia de la expresión en las ecuaciones es calculada mediante los valores definidos en las secciones correspondientes. Cabe aclarar que es posible utilizar paréntesis para agrupar subexpresiones.

\item La asociación del símbolo no terminal con el atributo se denomina \textbf{instancia}. La misma se corresponde con la ocurrencia del símbolo. 

Se compone de tres partes:
\begin{itemize}
\item Símbolo no terminal.
\item Índice sintáctico, comenzando de 0 para la primera ocurrencia.
\item Atributo.
\end{itemize}
\begin{center} \underline{Ejemplo:}\  
\fbox{\ E[2].type\ }\end{center} 

Asocia al símbolo ``E'' con el atributo ``type'' en la ocurrencia 3 del símbolo.

\end{enumerate}

\subsubsection*{Ejemplos}
\begin{enumerate}

\item 
\begin{center}

\fbox{\ E ::= E '+' E \ compute\ 
                       E[0].valor = E[1].valor + E[2].valor; 
                       end;\ }\end{center}

El ejemplo muestra una regla del símbolo ``E'' que contiene una ecuación que define el atributo \texttt{valor}. Sin consideramos, una gramática bien definida (ver \ref{XXX}), \texttt{valor} es un atributo sintetizado de ``E''. Otra consideración a tener en cuenta es la enumeración sintáctica de cada símbolo; en este ejemplo cada símbolo ``E'' presenta su índice sintáctico que asocia a los atributos con cada símbolo. Es decir, cada símbolo ``E'' es reconocido como un nuevo símbolo. A modo de aclaración, podríamos definir la ecuación de la siguiente, obteniendo el mismo poder expresivo para la regla:

\begin{center}
\fbox{\ E ::= T '+' F \ compute\ 
      E[0].valor = T[0].valor + F[0].valor; 
      end;\ }\end{center}

Cabe aclarar que \texttt{valor} debe ser atributo de ``T'' y ``F''.
\vspace{0.2cm}

\item

\begin{center}
\fbox{\ digit ::= '1';\ }\end{center}

Se observa una regla para el símbolo no terminal ``digit'' sin ecuaciones semánticas. 
\vspace{0.2cm}
\end{enumerate}

\subsection{Comentarios}

La especificación permite agregar comentarios. Para una mejor familiarización con el usuario se han utilizado las mismas reglas sintácticas que C y C++ para el adicionado de líneas o bloques de comentarios. Las cuales se detallan a continuación:

\begin{description}
\item [$\textbf{/*}$ comment $\textbf{*/}$] es la forma de inserción de bloques de comentarios.
\item [$\textbf{//}$ line commet] es comentario de una línea.
\end{description} 

\subsection{Ejemplo}

En el apéndice \ref{append:agwuuyang} observamos uno de los casos de prueba desarrollado para la fase de testing de \maggen. El mismo es presentado en pseudocódigo y luego escrito en el lenguaje de especificación. 

Una característica que motivó el desarrollo de este ejemplo es que se trata de una gramática MAG pero no ANCAG. Además, el mismo, es un caso de estudio analizado en una de las principales bases teóricas que han sido usadas para el desarrollo de \maggen[referencia bibliográfica paper]. 

En la presentación del ejemplo en el lenguaje de especificación, se observa en principio (línea 1 a 7) un bloque de comentario y luego los bloques que definen la gramática como se ha analizado en las secciones anteriores; bloque semántico de la línea 8 a 13 luego el de atributos y a partir de la línea 25 el bloque de reglas con sus respectivas ecuaciones.

 
\section{Parser del lenguaje, representación interna y chequeos}

El parser del lenguaje de especificación se llevó a cabo utilizando las librerías \boost\ \spirit. Detalles de este tema, son tratado puntualmente en \ref{XXX}. 

En esta sección nos encargaremos de algunas consideraciones del parser desde el punto de vista de su funcionamiento, algunos detalles en la representación interna y de los chequeos realizados sobre la entrada de \maggen\ para asegurar características de gramática bien definida.

\subsection*{Parser del lenguaje}

El parser de la entrada de \maggen\ esta dado por un recorrido secuencial y ante cualquier error sintáctico, la herramienta finaliza su ejecución indicando el error correspondiente. 

Supongamos la siguiente porción de una entrada de \maggen:

\vspace{0.3cm}
\begin{lstlisting}[basicstyle=\footnotesize, numbers=left, firstnumber=10, numbers=left, language=specmag, linewidth=9cm, columns=fullflexible]
...
semantic domain
  sort ecuacion, lista;

  /* List of Operators */
  op infix    10, left) +: int, int -> int;
...
\end{lstlisting}
\vspace{0.3cm}

La línea 15 presenta un error de sintaxis (falta de paréntesis), entonces \maggen\ finaliza el parser e informa de la siguiente manera:

\vspace{0.3cm}
\begin{lstlisting}[backgroundcolor=\color{white}, basicstyle=\footnotesize]
   * Parsing grammar ---------- [ FAIL ]

   ERROR: Parsing Failed, the following text will not be able to parse:

   File: ./examples/ag_count/ag_count.input
   Line: 17
   Col:  5
\end{lstlisting}
\vspace{0.3cm}

Notar que, la línea y columna donde se indica el error corresponde al inicio de la zona donde la interpretación fue fallida. Podría suceder en varios casos que el error no se detecte específicamente en la línea y columna que se indica, entonces lo conveniente es buscar el error a partir del punto especificado. Para este caso particular, se indica línea:17 y columna:5, este punto se encuentra sobre \texttt{op}, pero el error se observa seguido de \texttt{infix}.

\subsection*{Representación interna}

Las estructuras creadas para la representación interna de la gramática se encuentran dentro de los paquetes \texttt{Attr\_grammar} y \texttt{Expression\_tree} de \maggen. Detalles de implementación sobre estos paquete serán tratando en la sección \ref{XXX} (imp). 

Ahora nos encargaremos de algunas consideraciones respecto del diseño. 
\texttt{Expression\_tree} agrupa módulos para la representación de las expresiones de las ecuaciones y \texttt{Att\_grammar}, encapsula los demás componentes de la gramática.

El funcionamiento de \maggen\ esta dado por una instancia de la estructura llamada \texttt{Attr\_grammar}, la cual encapsula toda la información de la gramática de atributos parseada. La misma contiene los elementos que se agrupan en los paquetes anteriormente nombrados y es la que desencadena el cálculo de planes, secuencias de visita y, por último, la generación de código. 
 
En la figura \ref{fig:disen} se presenta un diagrama que muestra la interacción de esta estructura en el funcionamiento de \maggen.

\begin{figure}[h!]\centering
\includegraphics[width=450pt,height=180pt]{Disen.png}
\caption{\label{fig:disen}Interacción de Attr\_grammar en \maggen}
\end{figure}

Analicemos ahora el diseño de los paquetes nombrados arriba, y con ellos la estructura \texttt{Attr\_grammar}.  En la figura \ref{fig:disen2} se muestra un diagrama con la representación interna de una gramática dentro de \maggen.

\begin{figure}[h!]\centering
\includegraphics[width=450pt,height=297pt]{Disen2.png}
\caption{\label{fig:disen2}Diseño interno de una gramática de atributos en \maggen}
\end{figure}

Notemos algunas observaciones del diseño que muestra el diagrama:

\begin{itemize}
\item La relación entre los paquetes se produce por un lado, mediante la clase \texttt{Rule}, en el sentido de que toda regla contiene un conjunto de ecuaciones y cada una de estas esta definida a través de un \textit{l\_value:}\texttt{Expr\_instance} y un \textit{r\_value:}\texttt{Expression}. Por otro lado, \texttt{Expr\_instance} se vincula con \texttt{Symbol} y \texttt{Attribute} y \texttt{Expr\_function} con \texttt{Function}.

\item Toda la información de una gramática de atributos esta representada en la clase \texttt{Attr\_grammar} y por ende, el ciclo de vida de cada de uno de sus componentes es administrado por esta clase, durante todo el funcionamiento de \maggen. 
\end{itemize}

\subsection*{Chequeos}
\label{subsec:check}

El conjuntos de chequeos que se realizan sobre la gramática de entrada a \maggen, están directamente relacionados con el concepto de gramática bien definida analizado en el cap \ref{XXX}. Además, se aplican una serie de chequeos extras para evitar cálculos inconsistentes en las etapas posteriores. La totalidad de los chequeos, son realizados sobre el bloque de reglas de la gramática\footnote{En su mayoría los chequeos se realizan sobre las ecuaciones de las reglas.}, debido a que este, es el más significativo y sobre el cual se apoyan los cálculos posteriores.

Los chequeos realizados son clasificados en sintácticos y semánticos, los primeros, en su mayoría, son realizados durante el parser, en cambio, los chequeos semánticos se realizan luego del parser de cada regla, aplicando escaneos específicos. De estos últimos nos encargaremos en esta sección.
El módulo que agrupa estos chequeos, se ubica en el paquete \texttt{Parser} de \maggen\ y se denomina \texttt{Semantics\_checks}.

A continuación se detallan dichos chequeos:

\begin{description}
\item [Precedencia] El chequeo de precedencia consiste en preservar la precedencia definida de cada operador. Dicho chequeo, es realizado sobre cada una de las ecuaciones definidas en la gramática. Por ejemplo:\\ Dada la siguiente ecuación:

\begin{center}
 \fbox{ E[0].valor = E[1].valor + E[2].valor * E[2].valor }
\end{center}

Su interpretación está dada por la definición de la precedencia de los operadores \texttt{+} y \texttt{*}(se asume que los dos operadores son infijos y están bien usado). Si tomamos \texttt{*} con mayor precedencia que \texttt{+}, \maggen\ interpreta implícitamente como si la ecuación tuviera paréntesis:

\begin{center}
 \fbox{ E[0].valor = E[1].valor + (E[2].valor * E[2].valor) }
\end{center}

El uso de paréntesis en las expresiones define explícitamente la prioridad de los operadores, por lo que, \maggen\ asume esa precedencia. Por ejemplo en la ecuación vista arriba, si la definimos utilizando paréntesis, es decir:\  
 \fbox{E[0].valor = (E[1].valor + E[2].valor) * E[2].valor}\ la interpretación es tomada en ese sentido.

\item [Asociatividad] El chequeo de asociatividad realiza un análisis sobre las expresiones de las ecuaciones, para asegurar la asociatividad definida de cada operador. Por ejemplo, si se ha definido un operador \texttt{non\_assoc}, se espera que el uso del mismo sea consistente con esa definición, es decir, no se considere una posible asociación del mismo. 

Cuando se utilizan paréntesis en la expresión, \maggen\ asume la asociatividad que se especifica explícitamente.

\item [Alcanzabilidad] Es una característica importante a tener en cuenta sobre los símbolos de la gramática. Este chequeo, realiza un análisis sobre la totalidad de las reglas en busca de símbolos no terminales no alcanzables desde el símbolo inicial. Este caso no es considerado error fatal en \maggen, sino como \textit{warning}.

\item [Condiciones de AG] Este chequeo tiene en cuenta un conjunto de condiciones que debe cumplir la gramática. Ellos son:

\begin{itemize}
\item Cada regla debe definir todos los atributos sintetizados del símbolo de la parte izquierda.
\item Cada regla debe definir todos los atributos heredados de los símbolos de la parte derecha.
\item Cada regla sólo define los atributos de los símbolos que participan en dicha regla.
\item En caso de redefinición alguna instancia en la regla, la misma es ignorada.
\item Los índices de las instancias deben ser consistente con la cantidad de apariciones del símbolo, en la regla. Ejemplo: \\En la siguiente regla:\ \fbox{ S ::= S T }\ los índices posibles de las instancias son \texttt{0} y \texttt{1} para el símbolo ``S'' y \texttt{0} para el símbolo ``T''.
\item La gramática debe respetar las condiciones exigidas para una gramática extendida. 
\end{itemize}
\end{description}

\section{Construcción de grafos, planes y secuencias de visita}

En la figura \ref{fig:disen} pudimos analizar el funcionamiento de \maggen, teniendo en cuenta la estructura \texttt{Attr\_grammar}, en esta sección abordaremos detalles en el diseño del paquete \texttt{Builder}, específicamente la construcción de grafos, de planes y de secuencias de visita. Un detalle a tener en cuenta es que, a partir de esta etapa, todas las manipulaciones son realizadas sobre la sección de ecuación de cada reglas.

\subsection*{Construcción de grafos}
\label{subsec:graph}

Detalles de implementación serán analizando en la sección \ref{XXX}, ahora tomaremos un par de minutos para mencionar algunas consideración con respecto al funcionamiento de los grafos en \maggen.\\

La construcción de grafos se realiza en el modulo \texttt{builder\_graphs}. \maggen\ crea 4 tipos de grafos, que se corresponden con los detallas en \ref{sec:pre-grafos}:

\begin{itemize}
\item Grafo DP, ver \ref{dpgraph}.
  \begin{figure}[h!]\centering
    \includegraphics[width=200pt,height=77pt]{graph/dp.png}
  \caption{\label{dpgraph} Grafo DP.}
  \end{figure}

\item Grafo Down, ver \ref{downgraph}.
  \begin{figure}[h!]\centering
    \includegraphics[width=75pt,height=97pt]{graph/down.png}
  \caption{\label{downgraph} Grafo Down.}
  \end{figure}

\item Grafo DCG, ver \ref{dcggraph}.
  \begin{figure}[h!]\centering
    \includegraphics[width=200pt,height=101pt]{graph/dcg.png}
  \caption{\label{dcggraph} Grafo DCG.}
  \end{figure}

\item Grafo ADP, ver \ref{adpgraph}.
  \begin{figure}[h!]\centering
    \includegraphics[width=200pt,height=209pt]{graph/adp.png}
  \caption{\label{adpgraph} Grafo ADP.}
  \end{figure}
\end{itemize}

Las figuras\footnote{\label{foot:graph} Imagen generada utilizando la herramienta \textit{graphviz} sobre el archivo \texttt{.dot} generado por \maggen.} muestran un ejemplo de cada tipo de grafo, generados a partir del ejemplo analizado en el apéndice \ref{append:agwuuyang}.

La construcción de cada tipo de grafo respeta los principios analizados en el capítulo \ref{XXX}. 

De de los 4 tipos de grafos analizados, los necesarios para el cómputo de etapas siguientes, son los ``ADP graph''. Los demás, son requeridos como cálculo previo para la construcción de estos.

\subsection*{Construcción de planes}

La etapa de construcción de planes, tal como lo muestra el diagrama de la figura \ref{fig:disen}, se realiza en el paquete ``Builder''. El cálculo de planes en \maggen\ se basa en lo analizado en el cap \ref{XXX} y teniendo en cuenta estos dos puntos:

\begin{enumerate}
\item El punto de entrada para el cálculo de los planes esta dado sobre los grafos ADP. 
\item El cálculo de planes se basa en un orden topológico de la evaluación de los atributos de los símbolos, teniendo en cuenta los distintos contextos posibles.
\end{enumerate}

En la sección \ref{XXX} se tratan detalles de implementación, en donde podemos analizar el funcionamientos de lo tratado anteriormente, en especial el punto 2.
Un \textbf{plan} se compone de lista de números de ecuaciones a computar. Todo plan nos marca un orden de evaluación interpretando la lista de números de ecuaciones, de izquierda a derecha.

\subsubsection*{Planes proyectados}

Estos se obtienen a partir de los planes analizados anteriormente, proyectando el plan para cada símbolo de la parte derecha de la regla. La importancia de estos planes radica en la construcción de las secuencias de visita y además en el algoritmo principal de evaluación en la generación de código.

\begin{figure}[h!]\centering
 \includegraphics[width=250pt,height=139pt]{plans/plan.png}
\caption{\label{fig:plan}Plan obtenido por \maggen\ para la regla R1}
\end{figure}

En la figura\footnote{Figura obtenida con la herramienta \textit{graphviz} sobre el archivo \texttt{.dot} generado por \maggen.} \ref{fig:plan} observamos un plan obtenido por \maggen\ para el ejemplo del apéndice \ref{append:agwuuyang}. Este plan contiene el orden de los números de ecuación que pertenecen a la regla del plan, los planes proyectados son computados sobre el plan total, es decir con todas las dependencias. Para aclarar este echo, observemos los planes proyectados obtenidos:\\

\begin{tabular}{l l}
\includegraphics[width=220pt,height=35pt]{plans/plan_proj1.png} &
\includegraphics[width=220pt,height=73pt]{plans/plan_proj2.png} 
\end{tabular}

\begin{center}
 \includegraphics[width=220pt,height=36pt]{plans/plan_proj3.png}
\end{center}

Notar que cada plan proyectado ha capturado las ecuaciones de cada símbolo de la parte derecha para el cómputo de sus atributos, dependiendo del contexto. Es decir, en el caso del símbolo ``Y'' su orden ha sido computado observando las dependencias de la regla R2. Estas dependencias son necesarias para el cálculo del plan completo en las ecuaciones 2 y 4. 

\subsection*{Construcción de secuencias de visita}

La etapa de construcción de secuencias de visita, tal como lo muestra el diagrama de la figura \ref{fig:disen}, se realiza en el paquete ``Builder''. Las mismas, son computados a partir de los diferentes planes obtenidos en el sección anterior.

El funcionamiento para la construcción de las secuencias, esta dado por la aplicación de una especie de \textit{simulación}, para la evaluación de cada atributo de los símbolos. El resultado de esta simulación, son los valores que conforman la secuencia de visita, tal como se ha analizado en la sección \ref{XXX}. Estos valores siguen la siguiente interpretación: 

\begin{description}
\item [Compute] Valor mayor que cero que representa el número de la ecuación a resolver\footnote{La ecuación a computar pertenece a la regla del plan corriente.}.
\item [Visit] valor menor que cero que representa el número nodo hijo a visitar\footnote{El nodo hijo esta dado por el contexto de la regla del plan corriente.}.
\item [Leave] valor ``0''.
\end{description}

A modo de ejemplo observemos las siguientes secuencias de visita generada por \maggen\ para el ejemplo analizado en el apéndice \ref{append:agwuuyang}:

\begin{description}
\item [\{-7,0,-8\}] Secuencia de visita para la regla \texttt{R3} (sin contexto inferior). En este caso, la secuencia de visita se traduce a lo siguiente:

\begin{enumerate}
\item \textbf{Computar} la ecuación 7.
\item \textbf{Leave}\footnote{El leave retorna el control a la secuencia de visita de contexto superior, es decir, desde donde se invocó a esta secuencia.}.
\item \textbf{Computar} la ecuación 8.
\end{enumerate}

\item [\{-11,1,-12,-10\}] Secuencia de visita para la regla \texttt{R5} con el contexto de \texttt{P2}. En este caso, la secuencia de visita se traduce a lo siguiente:

\begin{enumerate}
\item \textbf{Computar} la ecuación 11.
\item \textbf{Visitar} el nodo hijo 1, es decir \texttt{Y}, como el contexto es \texttt{P2}, significa visitar a R2.
\item \textbf{Computar} la ecuación 12.
\item \textbf{Computar} la ecuación 10.
\end{enumerate}
\end{description}

Cabe aclarar que todas las secuencias de visita tienen un \textbf{leave} implícito al final, es decir, cuando se completo la computación de la secuencia se retorna a su ámbito de invocación.

\subsubsection*{Heurística de la simulación}

El punto principal del cual se basa la heurística es, evaluar el plan buscando las dependencias de cada ecuación en el contexto del mismo. Veamos los pasos básicos a tener en cuenta con el siguiente ejemplo:\\

Supongamos uno de los planes\footnote{Es importante notar el hecho de que cada plan se conforma de los números de ecuaciones a computar.} calculados por \maggen\ para el ejemplo del apéndice \ref{append:agwuuyang}:\\

\underline{Plan:} \{ 2, 3, 4, 1 \}. Ver figura \ref{fig:plan}.

\begin{enumerate}
\item Se recorre el plan tomando en cada paso una de las ecuaciones. Para este caso particular comenzamos con la ecuación 2.

\item Dada la ecuación \texttt{i}\footnote{Para este caso particular \textit{i} toma los valores 0,1,2,3.}, en el plan, debemos computar \textit{l\_value} de la ecuación. Para ello debemos resolver todas las dependencias dadas por \textit{r\_value}.

\item Dada una dependencia de la ecuación, primero se chequea si las misma fue computada en algún paso anterior, sino, analizamos de la siguiente manera:

\begin{itemize}
\item Si la dependencia proviene de una instancia que pertenece al \textbf{símbolo de la parte izquierda de la regla} y además contiene un \textbf{atributo heredado}, entonces estamos en condiciones de realizar un ``\texttt{leave}''.

\item Si la dependencia proviene de una instancia que pertenece a un \textbf{símbolo de la parte derecha de la regla} y además contiene un \textbf{atributo sintetizado}, entonces estamos en condiciones de realizar un ``\texttt{visit}''. En este caso, debemos analizar, según el contexto, cual es el plan (nodo hijo) se debe visitar. 
\end{itemize}

Notar que en los dos puntos anteriores, nos quedan los casos de dependencia perteneciente al símbolo de la parte izquierda con atributo sintetizado y dependencia de símbolo de la parte derecha con atributo heredado, pero estos casos, son los que deben definirse en este ambiente y como partimos del plan evaluación, el orden de dependencias es consistente con la demanda de las mismas.

\item Luego de la obtención de todas las dependencias, se realiza un \textbf{compute} del \textit{l\_value} y se marca a este como \texttt{evaluado}. El paso siguiente es avanzar una ecuación en la lista que impone el plan y realizar los mismos tratamientos.
\end{enumerate} 

Para mas detalle observemos la figura \ref{fig:simul}.

\begin{figure}[h!]\centering
\includegraphics[width=300pt,height=525pt]{simu.png}
\caption{\label{fig:simul}Heurística cómputo de secuencia de visita}
\end{figure}

\newpage

El resultado del ejemplo, aplicando los pasos tratados arriba, es presentado en el diagrama \ref{fig:resul_vis}.

\begin{figure}[h!]\centering
\includegraphics[width=300pt,height=160pt]{plan2seq.png}
\caption{\label{fig:resul_vis} Ejemplo de Secuencia de visita}
\end{figure}

Notar que para el cómputo de las secuencias de visitas totales nos basta con lanzar la simulación analizada anteriormente para los planes iniciales\footnote{Los planes iniciales son aquellos que provienen de regla inicial.}. La explicación de esto se sustenta en las propiedades garantizadas con los chequeos en la gramática, principalmente la propiedad de alcanzabilidad. De esta forma, los planes iniciales lanzan los demás planes necesarios para el cómputo total de las secuencias.

\section{Generación de Código}

La etapa final de \maggen\ esta dada por la generación de código para el evaluador estático. Como hemos analizado en el diagrama visto en la figura \ref{fig:disen}, esta etapa se realiza en el paquete ``Builder'', específicamente en el modulo \texttt{Builder\_code}.

La etapa de generación de código produce dos archivos: \textit{interface} (.hpp) e \textit{implementación} (.cpp). En el apéndice \ref{append:agwuuyangcode} observamos el código generado para el ejemplo de Wuu Yang ya analizado durante todo este capítulo.
A continuación abordaremos algunas consideraciones sobre la generación de código en \maggen\ teniendo en cuenta lo observado en el apéndice.

Consideraciones de la clase:

\begin{description}
\item [Atributos] Cabe aclarar que la totalidad de los atributos tiene visibilidad privada.

\vspace{0.3cm}
\begin{lstlisting}[basicstyle=\scriptsize, backgroundcolor=\color{white}, language=c++, columns=fullflexible, linewidth=7cm]
vector <Visit_sequence> v_seq;
vector <Order_rule>       contexts_rule;
vector <Plan>                eval_plans;
vector <Plan_project>    eval_plans_project;
vector <Rule>                rules;
\end{lstlisting}
\vspace{0.3cm}

Estos, son usados por los métodos del evaluador generado por \maggen. Podemos hacer una diferencia en el echo de que, \texttt{v\_seq} es usado directamente por el algoritmo de evaluación, en cambio los demás son usados por algoritmos previos a este. Cada uno de los tipos usados para estos atributos son definidos en otro módulo, el cual analizaremos mas adelante.

\item [Métodos] Es necesario tengamos en cuenta visibilidad:

\begin{itemize}
\item Privados:

\vspace{0.3cm}
\begin{lstlisting}[basicstyle=\scriptsize, backgroundcolor=\color{white}, language=c++, columns=fullflexible, linewidth=13cm]
void add_plan(const Key_plan &k_plan, unsigned short index_order);
void add_plan_project(const Key_plan_project &k_plan_p, unsigned short index_order);
void compute_eq(int num_eq, struct Node *root);
void traverse(struct Node * node, unsigned short order);
void eval_visiter(struct Node *root);
\end{lstlisting}
\vspace{0.3cm}

Estos métodos son usados internamente por el evaluador generado por \maggen\ teniendo en cuenta lo siguiente:\\
\texttt{compute\_eq} tiene la responsabilidad de invocar a los \textbf{compute} de cada ecuación y \texttt{eval\_visiter} tiene la responsabilidad de los \textbf{visit} a nodos. Notar que, estos métodos trabajan sobre las secuencias de visita.

El método \texttt{traverse} recorre el AST de entrada al evaluador y asigna a cada nodo un plan de evaluación\footnote{Los planes que asigna el método traverse son los generados estáticamente por \maggen.} y con ello una secuencia de visita correspondiente.

\texttt{add\_plan} y \texttt{add\_plan\_project} agregan planes y planes proyectados respectivamente, los mismos son usados en la inicialización del evaluador (constructor de clase).

\item Públicos:

\vspace{0.3cm}
\begin{lstlisting}[basicstyle=\scriptsize, backgroundcolor=\color{white}, language=c++, columns=fullflexible, linewidth=6cm]
maggen();
void print_visit_seqs();
void translates_visit_seqs();
void evaluator_mag(struct Node *root);
\end{lstlisting}
\vspace{0.3cm}

Estos, son los servicios públicos que ofrece el evaluador generado por \maggen. El métodos mas importante, es \texttt{evaluator\_mag}, el cual pone en funcionamiento el evaluador generado por \maggen. El parámetro tomado por el método representa la raíz del AST que se desea evaluar.

El constructor de clase\footnote{El nombre de la clase y por ende el del constructor de la misma depende de los parámetros con los cuales se invocó a \maggen. VER USO \ref{XXX}} realiza la inicialización de los atributos de la misma. Los valores de inicialización de los atributos son obtenidos por los cómputos de cada etapa de \maggen\ vistas en todo este capítulo.

Los dos métodos anexos, \texttt{print\_visit\_seqs} y \texttt{translates\_visit\_seqs} pueden ser usados para visualizar las secuencias de visita del evaluador. Los dos realizan la misma funcionalidad, pero muestran las secuencias de visita de manera diferente, como lista de valores o como secuencia de \texttt{compute}, \texttt{visit} o \texttt{leave} (detalle de secuencia de visita en \ref{XXX}).
\end{itemize}
\end{description}

Además de la clase, \maggen\ genera \texttt{struct} para cada uno de los símbolos de la gramática y para cada uno implementa el método \texttt{to\_string()} que se responsabiliza de como mostrar por pantalla cada símbolo, teniendo en cuenta sus atributos. Para mas detalle analizar en el apéndice \ref{append:agwuuyangcode}, específicamente los \texttt{struct} para los símbolos \texttt{S, X, Y, Z}.

Los dos módulos analizados arriba, generados por \maggen, se apoyan sobre dos módulos más, que son anexados de manera estática por la herramienta, ellos son: \texttt{Node.hpp} y \texttt{Plan.hpp}.

Los mismos contienen definiciones de ``tipos'' y ``métodos'' necesarios por el el evaluador generado.

\subsection{Cabecera: \texttt{Node.hpp}}

El tipo de datos nodo de un AST, se encuentra definido en este archivo. Los campos del mismo son:
\begin{items}
\item \texttt{struct Node *parent:} referencia al nodo superior.

\item \texttt{vector <struct Node*>\ childs:} listado de referencias a los hijos.

\item \texttt{unsigned short rule\_id:} identificador de la regla que representa el nodo.

\item \texttt{unsigned short visit\_seq\_index:} índice de la secuencia de visita que le corresponde al nodo para su evaluación.

\item \texttt{unsigned short pos\_visit\_seq:} posición desde donde debe comenzar a recorrerse la secuencia de visita.
\end{items}

Además se encuentra su constructor y una funcionalidad para agregar hijos.

\subsection{Cabecera: \texttt{Plan.hpp}}

Aquí se encuentran las definiciones de tipos necesarios para el evaluador:

\begin{items}
\item Orden de evaluación de ecuaciones:
\begin{lstlisting}[basicstyle=\scriptsize, backgroundcolor=\color{white}, language=c++, columns=fullflexible, linewidth=7.5cm]
typedef vector <unsigned short> Order_eval_eq;
\end{lstlisting}

\item Orden de evaluación de reglas (contexto):
\begin{lstlisting}[basicstyle=\scriptsize, backgroundcolor=\color{white}, language=c++, columns=fullflexible, linewidth=7cm]
typedef vector <unsigned short> Order_rule;
\end{lstlisting}

\item Clave para planes de evaluación:
\begin{lstlisting}[basicstyle=\scriptsize, backgroundcolor=\color{white}, language=c++, columns=fullflexible, linewidth=4.3cm]
typedef struct k_plan
{
    unsigned short  id_plan;
    unsigned short  plan;
    ...
} Key_plan;
\end{lstlisting}

\item Clave para planes de evaluación proyectados:
\begin{lstlisting}[basicstyle=\scriptsize, backgroundcolor=\color{white}, language=c++, columns=fullflexible, linewidth=5.5cm]
typedef struct k_p_project
{
    Key_plan        id_plan_project;
    unsigned short  node_project;
    unsigned short  index_ocurrence;
    ...
} Key_plan_project;
\end{lstlisting}

\item Secuencia de visita:
\begin{lstlisting}[basicstyle=\scriptsize, backgroundcolor=\color{white}, language=c++, columns=fullflexible, linewidth=5.7cm]
typedef vector <int> Visit_sequence;
\end{lstlisting}

\item Versión reducida de regla:
\begin{lstlisting}[basicstyle=\scriptsize, backgroundcolor=\color{white}, language=c++, columns=fullflexible, linewidth=6cm]
typedef vector <unsigned short> Rule;
\end{lstlisting}

\item Plan de evaluación:
\begin{lstlisting}[basicstyle=\scriptsize, backgroundcolor=\color{white}, language=c++, columns=fullflexible, linewidth=7.2cm]
typedef pair <Key_plan, unsigned short> Plan;
\end{lstlisting}

\item Plan de evaluación proyectado:
\begin{lstlisting}[basicstyle=\scriptsize, backgroundcolor=\color{white}, language=c++, columns=fullflexible, linewidth=9.5cm]
typedef pair <Key_plan_project, unsigned short> Plan_project;
\end{lstlisting}
\end{items}

\normalsize
