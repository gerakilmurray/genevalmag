\chapter{Acerca de \maggen}
\label{chap:disen_}
\minitoc

\section{Qu\'e es \maggen}

\section{Lenguaje de especificaci\'on de las MAG}

El lenguaje de especificación utilizado para la descripción de una Gramática de atributos (MAG) fue definido en el marco de este proyecto. Esto permite definir una gramática de atributos como input de \maggen.
 
La secciones que conforman la descripción de una gramática de atributos se corresponden con las características que definen a una gramática de atributos como tal (ver capítulo de GA).
 
Informalmente, los bloques que conforman la especificación son:

\begin{description}
\item [Bloque Dominio Semántico] Destinando a la declaración de sort, operadores y funciones que se utilizarán en el bloque de ecuaciones. Este bloque es denominado ``\texttt{semantic domain}''.
\item [Bloque de Atributos] Destinando a la declaración y definición de los atributos asociados a cada símbolo. Este bloque es denominado ``\texttt{attributes}''.
\item [Bloque de Reglas] Destinado a la declaración y definición de las reglas sintácticas de la gramática con sus correspondientes ecuaciones semánticas para cada atributo asociado a cada símbolo. Este bloque es denominado ``\texttt{rules}''.
\end{description}

A los tres bloques analizados anteriormente, podemos clasificarlos en dos, teniendo en cuenta su comportamiento o funcionalidad dentro de la especificación. Los dos primeros, son bloques puramente declatativos o dedicados a la definición de elementos que serán utilizados en el tercer bloque. Este bloque, es considerado el de mayor áuge, ya que marca la sintáxis y semántica de la gramática.

Cada bloque del lenguaje de especificación contiene su sintáxis propia para su definción, es por ello que, en las secciones siguientes nos encargaremos de mostrar detalles de cada uno de ellos.

El análisis de cada bloque se realizará de una manera más formal y observando cada bloque como partes de una gramática.

Entonces, sea \textbf{G: CFG} que define el lenguaje de especificación para el archivo de entrada aceptado por \maggen. Se define la siguiente regla de \textbf{G: CFG} para el símbolo inicial ``S''.

\begin{center}
\lstset{language=inform}
% \scriptsize
\begin{lstlisting}
S   =   'semantic domain' decl_Sd
    |   'attributes' decl_attrs
    |   'rules' decl_rules
\end{lstlisting}
\end{center}

En las secciones siguientes se presentaran los símbolos \textit{decl\_Sd}, \textit{decl\_attr} y \textit{decl\_rules} con más detalle.  

\subsection{Bloque Dominio semántico}

El bloque ``\texttt{semantic domain}'' es el encargado de la definición de elementos que serán necesarios para los bloques siquientes. 

El bloque semántico esta subdividido en 3 secciones, que se corresponden con la definición de sort, operadores y funciones, cada una con su sintáxis propia. 

Entonces se define el símbolo \textit{decl\_Sd} como:

\begin{center}
\lstset{language=inform}
% \scriptsize
\begin{lstlisting}
decl_Sd = (decl_sort)*
        | (decl_operator)*
        | (decl_function)*
\end{lstlisting}
\end{center}

El uso de ``\texttt{*}'' (``0 o mas veces'') en cada subsección y no de ``\texttt{+}'', esta dado, debido a que cada una de estas secciones son opcionales, es decir, no se obliga a la existencia de cada sección. Esto es, ya que podría interesar la definición de una gramática que no cuente con funciones, por ejemplo.

La sintáxis particular de cada sección se analiza individualmente a continuación.

\subsubsection{Declaración de sort}
La subsección de ``\texttt{sort}'' declara todos los posibles tipos que seran necesesarios para las declaraciones siguientes. Todo \texttt{sort} es distinguible en el lenguaje mediante un nombre.

A continuación se define el símbolo \texttt{decl\_sort}

\begin{center}
\lstset{language=inform}
% \scriptsize
\begin{lstlisting}
decl_sort = 'sort' NAME_SORT ';'
\end{lstlisting}
\end{center}

\textit{``NAME\_SORT''} representa el nombre del sort o tipo. El mismo, se corresponde con la definición de un identificador en el común de los lenguajes de programación. Es decir, acepta caracteres alfanuméricos y guiones bajos, restringiendo a los caracteres numéricos como primer caracter, como también palabras reservadas definidas por la especificación (para mas detalles ver ANEXO  XXX de implementación en \spirit).\\
% \ref{append:grammarspirit}

\underline{Ejempo:}\ \fbox{\texttt{sort int;}}\\
\vspace{0.2cm}
Esta línea declara el tipo ``int''.\\

\subsubsection*{Tipos predefinidos por el lenguaje}
\label{sec:typepredefined}

El lenguaje de especificación contempla los siguiente tipos básicos:

\begin{itemize}
\item [int] Tipo entero de 32 bits.

\item [float] Tipo real en punto flotante de 32 bits.

\item [bool] Tiene en cuenta los valores \texttt{true} y \texttt{false}.

\item [char] Tipo char en el común de los lenguajes (encerrado entre comillas simples).

\item [string] Cadenas de caracteres (entre comillas dobles).
\end{itemize}

En caso que se declaren estos explícitamente en la especificación, la línea no es reflejada en el funcionamiento interno de \maggen.

\subsubsection{Declaración de operadores}
La sección destinada a la declaración de \texttt{operadores} acepta 3 tipos de operadores, los cuales, difieren en su forma de uso y cantidad de operandos. Denominados, infijo, prefijo y posfijo. 

La interpretación de cada uno, esta dada por la interpretación natural común a todos los lenguajes de programación, a modo de ejemplo se muetran un operador de cada tipo para evitar problemas en esta sección:

\begin{itemize}
\item \underline{Operador prefijo:} \textit{Ejemplo:} -2. Operador de menos unario. 

\item \underline{Operador posfijo:} \textit{Ejemplo:} i++. Operador de auto-incremento en lenguaje C y C++.

\item \underline{Operador infijo:} \textit{Ejemplo: 2 + 3}. Operador ``suma''.
\end{itemize}

A continuación se define el símbolo \texttt{decl\_operator}:

\begin{center}
\lstset{language=inform}
% \scriptsize
\begin{lstlisting}
decl_operator = 'op' infix  mode_op NAME_OP ':'
                NAME_SORT ','  NAME_SORT '->' NAME_SORT ';' 
              | 'op' prefix mode_op NAME_OP ':'
                NAME_SORT '->' NAME_SORT ';'               
              | 'op' posfix mode_op NAME_OP ':'
                NAME_SORT '->' NAME_SORT ';'
              | 'op' mode_op NAME_OP ':'
                NAME_SORT '->' NAME_SORT ';'

mode_op = '(' m_op ')'
        | lambda

m_op    = NUM_PRECEDENCE ',' assoc
        | '_' ',' assoc
        | NUM_PRECEDENCE ',' '_'
        | '_' ',' '_'

assoc   = (left | right | non-assoc) 
\end{lstlisting}
\end{center}

\textit{``NAME\_OP''} representa un identificador para el operador (infija, prefija y postfija). Las restricciones y detalles a tener en cuenta para este identificador son las mismas que se analizaron para ``NAME\_SORT''.

\textit{``NUN\_PRECEDENCE''} representa un número positivo que define la precedencia del operador. Cabe aclarar que a mayor número mayor la precedencia.

Es importante analizar el uso de ``\_'' para precedencia y asociatividad en el hecho de que estos datos son tomados opcionalmente, es decir se puede omitir dicha información. Lo mismo sucede con el tipo del operador (infijo, prefijo y postfijo). 

Para estos casos especiales se utilizarán los siguientes valores default:

\begin{description}
\label{desc:default}
\item [Precedencia] = \texttt{USHRT\_MAX}.

\item [Asociatividad] = \texttt{left}.

\item [Tipo de operador] = \texttt{prefix}.
\end{description}

Otro caso a tener cuenta es el uso de \texttt{non-assoc} como asociatidad del operador. Este caso define que el operador no tiene asociatividad, con lo que el uso del mismo en las ecuaciones debe respetar esta condición, en caso contrario se observará un error por mal uso.
A continuación, se analizan algunos ejemplos de declaraciones de operadores:\\

\underline{Ejempo 1:}\ \fbox{\texttt{op infix (\_,right) *: int, int -> int;}}\\
\vspace{0.2cm}
Esta línea declara el operador infijo ``\texttt{*}'' con precedencia default y asociatividad \texttt{right}. Esta línea también podría haber sido definida como:\\
\vspace{0.2cm}
\fbox{\texttt{op infix *: int, int -> int;}}\\
\vspace{0.2cm}
donde se usan valores default para precedencia y asociatividad.\\

\underline{Ejempo 2:}\ \fbox{\texttt{op prefix (60,non-assoc) \%: int -> int;}}\\
\vspace{0.2cm}
Esta línea declara el operador prefijo ``\texttt{\%}'' con precedencia \texttt{60} y asociatividad \texttt{non-assoc}. Esta línea también podría haber sido definida como:\\
\vspace{0.2cm}
\fbox{\texttt{op (60, non-assoc) \%: int -> int;}}\\
\vspace{0.2cm}
y en el caso que se desee usar valores de asociatividad y precedencia default asi:\\
\vspace{0.2cm}
\fbox{\texttt{op \%: int -> int;}}\\

\subsubsection{Declaración de funciones}
La noción de funciones dentro de la especificación es tomada con la noción natural de función matemática. Es decir, toda función esta definida mediante un identificador, un dominio y una imagen.

Definimos \texttt{decl\_function} como:

\begin{center}
\lstset{language=inform}
% \scriptsize
\begin{lstlisting}
decl_function = 'function' NAME_FUNC':' domain '->' NAME_SORT ';'

domain        = NAME_SORT ',' domain
              | NAME_SORT 
              | lambda
\end{lstlisting}
\end{center}

\textit{``NAME\_FUNC''} define el identificador de la función, en el cual se asumen las mismas restricciones tomadas para los identificadores analizados en las seccines anteriores. Cabe aclarar que se acepta un dominio vacío lo que permite el uso de funciones que solo retornan un valor.

Es importante tener en cuenta que las funciones son tomadas con los valores default de operador para asociatividad y precedencia \ref{desc:default}.\\

\underline{Ejempo:}\ \fbox{\texttt{function f:int, int, int, int -> real;}}\\
\vspace{0.2cm}
Esta línea declara la función ``\texttt{f}'' que tiene como entrada 4 elementos de tipo ``\texttt{int}'' y como salida un elemento de tipo ``\texttt{real}''.\\

\subsection{Bloque de Atributos}
En esta sección presentaremos el bloque ``attributes'' en detalle. La información que define un atributo dentro del lenguaje esta dado por: 

\begin{description}
\item [Nombre:] representa el nombre del atributo, el mismo respeta los requisitos de identidicador analizados anteriormente.

\item [Clase de atributo:] está dado por la clase del atributo, esto es sintetizado (\texttt{syn}) o heredado (\texttt{inh}).

\item [Tipo:] está dado por el tipo del atributo. El mismo corresponde a un tipo básico o a un sort definido en la sección de \textit{Sort}.

\item [Símbolos de pertenencia:] hace referencia a los símbolos a los cuales se asocia el atributo.
\end{description}

A continuación se define el símbolo \texttt{decl\_attrs} como:

\begin{center}
\lstset{language=inform}
% \scriptsize
\begin{lstlisting}
decl_attrs = (d_attr)+ 

d_attr = NAME_ATTR ':' '<' c_attr '>' NAME_SORT 'of' symbols;

symbols = '{'list_symbol'}' 
        | 'all'
        | 'all' '-' '{'list_symbol'}'

c_attr = inh
       | syn
       | lambda

list_symbol = SYMB_NON_TERMINAL ',' list_symbol
            | SYMB_NON_TERMINAL 
\end{lstlisting}
\end{center}

\textit{``NAME\_ATTR''} define el identificador de un atributo. Se tienen las mismas consideraciones que para el identificador de sort, operador y función.

\textit{``SYMB\_NON\_TERMINAL''} describe un símbolo no terminal de la gramática. En este punto se debe tener en cuenta que los símbolos utilizados deben ser símbolos no terminales utilizados en el bloque de reglas.

\textit{``NAME\_SORT''} declara el tipo del atributo, el mismo esta dado por un sort definido por el usuario o por un tipo predefinido por el lenguaje \ref{sec:typepredefined}.

Observaciones importantes a tener en cuenta:

\begin{itemize}
\item En la declaración de los símbolos a los cuales pertenece el atributos, ``\texttt{all}'' se interpreta como ``todos los símbolos'', es decir, el atributo declarado se asocia a todos los símbolos de la gramática. Además es posible utilizar el operado ``diferencia'' de conjuntos ``\texttt{-}'' para especificar el conjunto de símbolos a los cuales perteneces el atributo, como una expresión.

\item Si no se especifíca la clase del atributo (sintetizado o heredado) el mismo es tomado como el caso default a sintetizado.
\end{itemize}

Analicémos algunos ejemplos:\\

\texttt{Ejempo 1:}\ \fbox{\texttt{lexx : syn <string> of all - {T}}};\\
\vspace{0.2cm}
Se define el atributo ``\texttt{lex}'' sintetizado de tipo ``\texttt{string}'' para todos los símbolos excepto para el símbolo ``\texttt{T}''.\\

\underline{Ejempo 2:}\ \fbox{\texttt{type : inh <string> of all;}}\\
\vspace{0.2cm}
Se define el atributo ``\texttt{type}'' heredado de tipo ``\texttt{string}'' para todos los símbolos de la gramática.\\

\texttt{Ejempo 3:}\ \fbox{\texttt{grade : <int>  of {E, T};}}\\
\vspace{0.2cm}
Se define el atributo ``\texttt{grade}'' sintetizado (default) de tipo ``\texttt{int}'' para los símbolos ``\texttt{E}'' y ``\texttt{T}''.\\

\subsection{Bloque de reglas}
Por último el bloque de reglas. La interpretación de las reglas dentro del lenguaje esta dada por la definición de gramática libre de contexto.          

El símbolo terminal se considera un símbolo entre comillas simples (\texttt{'}).\\ 

\underline{Ejemplo:}\ \fbox{\texttt{'literal'}.}\\
\vspace{0.2cm}

Las ecuaciones describen las reglas semánticas que definen la sintáxis de la gramática. Cada ecuación define la interpretación semántica de los atributos de cada símbolo. Además se deben tener en cuenta los requisitos necesarios de una gramática bien definida (Ver capítulo XXX).

A continuación se define el símbolo \texttt{decl\_rules}:

\begin{center}
\lstset{language=inform}
% \scriptsize
\begin{lstlisting}
decl_rules = (d_rule)+ 

d_rule = SYMB_NON_TERMINAL '::=' rigft_symb decl_eqs

rigft_symb = (SYMB_NON_TERMINAL | SYMB_TERMINAL)+

decl_eqs = 'compute' d_eqs 'end;'
         | ';'

d_eqs = instance '=' right_eq ';'

right_eq = leaf
         | leaf OP_NAME leaf right_eq
         | (OP_NAME)+ leaf
         | leaf (OP_NAME)+
         | NAME_FUNC '(' right_eq ')' 

leaf = instance
     | LITERAL

instance = 'symb_non_terminal' '[' 'num_ins' ']' '.' 'name_attr'
            
\end{lstlisting}
\end{center}

\textit{``SYMB\_NON\_TERMINAL''} y \textit{``SYMB\_TERMINAL''} describen símbolos no terminales y terminales respetivamente. En este punto, se tiene en cuenta la diferenciación entre estos tipos de símbolos como se analizó en el párrafo anterior.
 
\textit{``OP\_NAME''} y  \textit{``NAME\_FUNC''} describen identificadores de operadores infijos, prefijos y posfijos (según su uso) y el de función respectivamente. Tanto los operadores como las funciones se asumen definidos en la sección ``\texttt{semantic domain}''.

\textit{``LITERAL''} describe los tipos de literales entero, real, caracter, string y bool con las siguientes consideraciones:

\begin{description}
\item [Entero] es considerado un número entero de 32 bits. 
\item [Real] es considerado un número en punto flotante de 32 bits. La separación de decimales se da mediante el punto (.).
\item [Caracter] es considerado un caracter cualquiera entre comillas simples (').
\item [String] es considerado una cadena de caracteres entre comillas dobles (`` '').
\item [Bool] representa los valores \texttt{true} y \texttt{false}.
\end{description}

Analicemos algunas cuestiones a tener en cuenta:

\begin{itemize}
\item Es posible definir una regla de la gramática sin sección de ecuaciones, para ello se debe omitir la sección de ``\texttt{compute}'' en la definición. Si se define la sección de ``\texttt{compute}'' el lenguaje obliga a definir \textbf{al menos una ecuación}.

\item La sintáxis para el uso de los operadores esta dada por el tipo del operador: infijo, prefijo o posfijo. Para las funciones se utiliza la manera natural de invocación de una función en el común de los lenguajes de programación. Esto es, mediante el nombre de la función y los parametros entre paréntesis.

\item La asociatividad y precedencia de la expresión en las ecuaciones es calculada mediante los valores definidos en las secciones correspondientes. Cabe aclarar que es posible utililizar paréntesis para agrupar subexpresiones.
\end{itemize}

Veámos algunos ejemplos:\\

\underline{Ejemplo 1:}\ \fbox{bla bla}
\vspace{0.2cm}

\underline{Ejemplo 2:}\ \fbox{bla bla bla}
\vspace{0.2cm}

\subsection{Comentarios}
La especificación permite agregar comentarios. Para una mejor familiarización con el usuario se han utilizado las mismas reglas sintácticas que C y C++ para el adicionado de líneas o bloques de comentarios. Las cuales se detallan a continuación:

\begin{description}
\item [$\textbf{/*}$ comment $\textbf{*/}$] es la forma de inserción de bloques de comentarios.
\item [$\textbf{//}$ line commet] es comentario de una línea.
\end{description} 

\subsection{Ejemplo}
El ejemplo presentado en la figura \ref{fig:ejemplo_mag} es uno de los casos de prueba desarrollado para la construcción de \maggen. La importancia de éste radica en que, el mismo, es un caso de estudio dado en una de las principales bases teóricas que han sido usadas para el sistema. La gramática de ejemplo es MAG pero no ANCAG.

En el ejemplo se observa en principio (línea 1 a 7) un bloque de comentario y luego los bloques que definen la gramática como se ha analizado en las secciones anteriores; bloque semántico de la línea 8 a 16 luego el de atributos y a partir de la línea 29 el bloque de reglas con sus respectivas ecuaciones.

\begin{figure}
\centering
\lstset{language=inform}
\scriptsize
\begin{lstlisting}
/**
  *  \file    Mag.txt
  *  \brief   Attribute Grammar example.
  *  \date    15/02/2010
  *  \author  Kilmurray, Gerardo Luis <gerakilmurray@gmail.com>
  *  \author  Picco, Gonzalo Martin <gonzalopicco@gmail.com>
  */

// Block of Semantic Domain
semantic domain
  // List of Operators 
  op infix  (10, left) +: int, int -> int;

// Block of Attributes
attributes
  s0 : syn <int> of {S};
  s1 : syn <int> of {X};
  s2 : syn <int> of {Y};
  s3 : syn <int> of {Y};
  s4 : syn <int> of {Z};
  i1 : inh <int> of {X};
  i2 : inh <int> of {Y};
  i3 : inh <int> of {Y};

// Block of Rules
rules
  // P1
  S ::= X Y Z
      compute  
          S[0].s0 = X[0].s1 + Y[0].s2 + Y[0].s3 + Z[0].s4;
          X[0].i1 = Y[0].s3;
          Y[0].i2 = X[0].s1;
          Y[0].i3 = Y[0].s2;
      end;

  // P2
  Y ::= 'm'
      compute
          Y[0].s2 = Y[0].i2;
          Y[0].s3 = 1;
      end;

  // P3
  Y ::= 'n'
      compute
          Y[0].s2 = 2;
          Y[0].s3 = Y[0].i3;
      end;

  // P4
  X ::= 'm'
      compute
          X[0].s1 = X[0].i1;
      end;
  
  // P5
  Z ::= Y
      compute
          Z[0].s4 = Y[0].s3;
          Y[0].i2 = 3;
          Y[0].i3 = Y[0].s2;
      end;           
\end{lstlisting}
\caption{Ejemplo ag\_wuu\_yang.input }
\label{fig:ejemplo_mag}
\end{figure}
 
\section{Estrucutas internas}
bla bla

\section{Disen\~o del evaluador est\'atico generado}

bla bla