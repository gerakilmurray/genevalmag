\chapter{Evaluación estática de MAG}
\label{chap:eval_est}
\minitoc

En este capítulo se presentan los algoritmos de construcción de cada tipo de grafo, así como los usados para el cómputo de planes de evaluación y sus respectivas secuencias de visita. En su mayoría, los mismos, se basan en los propuestos por Wuu Yang en \ref{wuu-yang1}. Mientras que el algoritmo para el cálculo de secuencias de visita fue íntegramente desarrollado e implementado en el marco de la tesis.

Para comprobar la correctitud de los algoritmos y lograr mayor grado de eficiencia, los mismos fueron testeados mediante la herramienta \textit{gcov} (Detalles en sección \ref{XXX}). La cual fue utilizada con mayor énfasis para el algoritmo de cómputo de secuencias de visita. En conjunto con los resultados proporcionados por \textit{gcov} y análisis teóricos, la heurística que implementa el algoritmo fue refinada en varias oportunidades.

\section{Algoritmos para cómputo de grafos}

Todos estos algoritmos tienen una característica en común, expresan las dependencias existentes entre los atributos de una gramática desde distinto aspectos. Por lo tanto en su construcción, los nodos y aristas son obtenidos de las relaciones entre dichos elementos.

\subsection*{Cómputo de DP}

Se debe generar un grafo DP por cada regla de la gramática. Es el más directo de construir, ya que por cada ecuación de la regla actual, se agrega una arista entre cada uno de los símbolos del \texttt{r-value} con destino el \texttt{l-value} de la ecuación. Obviamente se agregan los nodos necesarios y sin repeticiones. 

\begin{algorithm}[H]
\lstinputlisting[basicstyle=\scriptsize\ttfamily, language=specmag, numbers=left, columns=fullflexible]{input_file_code/compute_dp_wuu_yang}
\caption{\texttt{compute\_dp\_graphs}}
\end{algorithm}

\subsection*{Cómputo de Down}

Este tipo de grafo, se debe crear para cada uno de los símbolos no terminales de la gramática, considerando únicamente la relaciones de dependencia entre sus atributos.

\begin{algorithm}[H]
\lstinputlisting[basicstyle=\scriptsize\ttfamily, language=specmag, numbers=left, columns=fullflexible]{input_file_code/compute_down_wuu_yang}
\caption{\texttt{compute\_down\_graphs}}
\end{algorithm}

La función \texttt{project} lo que hace básicamente es dado un grafo, elimina todos los nodos y aristas relacionadas con esos nodos que no representen a los atributos que le pasan como parámetro.

\begin{algorithm}[H]
\lstinputlisting[basicstyle=\scriptsize\ttfamily, language=specmag, numbers=left, columns=fullflexible]{input_file_code/project_wuu_yang}
\caption{\texttt{project} sobre grafos}
\end{algorithm}

\subsection*{Cómputo de DCG}

Estos grafos se generan para cada regla de la gramática y considerando las dependencias entre los atributos del símbolo de la parte izquierda de la producción (\texttt{head}). Para computarlo se unen el grafo DP de la regla junto a todos los grafos Down de los símbolos de la parte derecha de la regla (\texttt{body}). Se utiliza nuevamente la función \texttt{project}.

\begin{algorithm}[H]
\lstinputlisting[basicstyle=\scriptsize\ttfamily, language=specmag, numbers=left, columns=fullflexible]{input_file_code/compute_dcg_wuu_yang}
\caption{\texttt{compute\_dcg\_graphs}}
\end{algorithm}

\subsection*{Cómputo de ADP}

Para generar estos grafos, Wuu Yang no plantea un algoritmo preciso aunque no es necesario ya que toda la heurística necesaria se encuentra en la definición de los mismos (ver \ref{mag:adpdef}).

Un grafo ADP corresponde a una regla bajo una cierta combinación de producciones para cada uno de sus hijos. Es decir, que para una misma regla pueden existir varios grafos ADP, ya que sus hijos pueden producir varios \textbf{contextos}\footnote{Ver \ref{XXX}.}.

\begin{algorithm}[H]
\lstinputlisting[basicstyle=\scriptsize\ttfamily, language=specmag, numbers=left, columns=fullflexible]{input_file_code/compute_adp_wuu_yang}
\caption{\texttt{compute\_adp\_graphs}}
\end{algorithm}

\section{Algoritmo de cómputo de planes}
\label{sec:comp-planes}
Luego de verificar que la gramática es MAG\footnote{Ver \ref{XXX}.}, se debe generar los planes de evaluación para la gramática. Cada ADP producirá un plan de evaluación, por lo que ambos tendrán el mismo identificador, es decir, la regla a la cual pertenece y el contexto que se aplicó a los símbolos no terminales de la misma.

Este algoritmo propuesto por Wuu Yang, es detallado en profundidad mostrando su correctitud\footnote{Ver \ref{XXX} para más detalles.}.

La idea principal es utilizar una cola de trabajos, en la cual se insertan un pares que contienen una regla y un orden de evaluación para sus atributos. Para cada uno de los grafos ADP asociados a la regla, se le computa su orden de evaluación para el contexto especificado por el grafo.

Luego, para cada uno de los símbolos no terminales de la parte derecha de la regla, considerando la producción que le corresponde según el contexto, se obtiene el plan proyectado. Ese nuevo par, se intenta insertar en la cola de trabajos para seguir con el cómputo de planes.

\begin{algorithm}[H]
\lstinputlisting[basicstyle=\scriptsize\ttfamily, language=specmag, numbers=left, columns=fullflexible]{input_file_code/compute_plan_wuu_yang}
\caption{\texttt{compute\_plans}}
\end{algorithm}

La función \texttt{compute\_order}, debe agregarle al grafo ADP la información inducida por el orden para evaluar los atributos del símbolo \textbf{head} de la regla a la que pertenece el grafo.

Para ello, como todo orden se puede ver como una secuencia, se agregan al grafo un nodo por cada elementos del orden y las aristas para todos los pares posibles\footnote{Ver más detalles en \ref{XXX}}.

\begin{algorithm}[H]
\lstinputlisting[basicstyle=\scriptsize\ttfamily, language=specmag, numbers=left, columns=fullflexible]{input_file_code/compute_order_wuu_yang}
\caption{\texttt{compute\_order}}
\end{algorithm}

La funcionalidad que cumple \texttt{project}, es dado un grafo purgarlo de todo elemento ajeno a el conjunto de ocurrencias de atributos especificados como parámetro. Pero para evitar que al eliminar nodos y aristas el grafo pierda información sobre las dependencias entre los atributos, se calcula previamente la clausura transitiva del grafo.

\begin{algorithm}[H]
\lstinputlisting[basicstyle=\scriptsize\ttfamily, language=specmag, numbers=left, columns=fullflexible]{input_file_code/project2_wuu_yang}
\caption{\texttt{project} orden de evaluación}
\end{algorithm}

\section{Algoritmo de cómputo de secuencias de visita}
\label{sec:algseqvisit}

Las secuencias de visitas, son traducciones de los planes de evaluación en secuencias compuestas por tres comandos\footnote{\texttt{compute}, \texttt{leave} y \texttt{visit}, ver más detalles en \ref{XXX}.} que permitan la navegación por el AST para su evaluación.

Este proceso fue diseñado e implementado para el desarrollo de \maggen. La generación se dividió en dos algoritmos, el primero se encarga de la inicialización de todas las secuencias de visitas y la invocación del segundo solamente para los planes de evaluación que pertenecen a la producción inicial de la gramática.

La traducción bajo demanda de los planes de evaluación, permite realizar optimizaciones como se explicará en el capítulo \ref{chap:implem} de implementación.

\begin{algorithm}[H]
\lstinputlisting[basicstyle=\scriptsize\ttfamily, language=specmag, numbers=left, columns=fullflexible]{input_file_code/generate_visit_sequences}
\caption{Generador de secuencias de visitas.}
\end{algorithm}

El segundo realiza un proceso recursivo para lograr la traducción. Como ya se explicó en \ref{XXX}, es una simulación del recorrido sobre el árbol en tiempo de evaluación.

Por lo que se debe llevar una secuencia de visita local, a la cual se le insertarán los distintos comandos. Además, será necesario una función que lleve cuáles son las instancias de atributos ya calculadas.

Como se hizo notar en \ref{}, existen pequeñas diferencias entre los comandos que integran la secuencia de visita a nivel teórico y los que realmente se implementaron. En esta sección, se verán desde el segundo punto de vista.

De esta forma, cuando se detecta un \texttt{visit}, se debe detectar a que hijo tiene que recursar, en base al plan actual, el cual tiene un contexto establecido, determinar el plan proyectado que será el orden de evaluación impuesto a nuestro hijo en la recursión. Al volver se debe actualizar todas las instancias de atributos que fueron computadas en el contexto inferior, para evitar futuras visitas innecesarias.

Con el mismo criterio, al producirse un \texttt{leave} por la necesidad de requerir que en el contexto superior se calcule una instancia de atributo, puede ser que se calculen más de lo que solicitó, por eso se deben actualizar la información de computados.

Una ecuación se podrá computar solamente cuando todo su \texttt{r-value} halla sido marcado como computado, ya sea mediante un \texttt{visit} o \texttt{leave}.

Por último, es necesario una función que combine y actualice la secuencia de visita global, con la que se calculó a nivel local. Esto es ya que una secuencia de visita puede ser completada en más de una visita.

\begin{algorithm}[H]
\lstinputlisting[basicstyle=\scriptsize\ttfamily, language=specmag, numbers=left, columns=fullflexible]{input_file_code/gen_visit_seq}
\caption{Función \texttt{gen\_visit\_seq}.}
\end{algorithm}


\section{Algoritmo de evaluación de atributos}
\label{sec:algevalattr}

Este algoritmo, no se encuentra implementado dentro de \maggen, sino dentro del evaluador generado. Se basa en dos etapas bien definidas y con propósitos diferentes. Se deben realizar dos recorridos del AST de entrada, en el primero es una barrida descendente en la que se seleccionan los planes de evaluación para cada regla almancenada en los nodos. En el segundo, no precisamente se realiza un recorrido uniforme, sino que se navega descendente y ascendentemente, se acuerdo a la secuencia de visita correspondiente al plan seleccionado en la primera etapa.

\begin{algorithm}[H]
\lstinputlisting[basicstyle=\scriptsize\ttfamily, language=specmag, numbers=left, columns=fullflexible]{input_file_code/eval_attribute_wuu_yang}
\caption{Evaluación de atributos}
\end{algorithm}

\begin{algorithm}[H]
\lstinputlisting[basicstyle=\scriptsize\ttfamily, language=specmag, numbers=left, columns=fullflexible]{input_file_code/traverse_wuu_yang}
\caption{\texttt{traverse}}
\end{algorithm}