
%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,pagebackref,hyperindex=true]{hyperref}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{subfigure}
\usepackage{multirow}
\usepackage[table]{xcolor}
\usepackage{color}

\newtheorem{definition}{Definición}[section]
\def\theoremname{Teorema}
\def\definitionname{Definici\'on}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\definecolor{gris}{rgb}{0.8,0.8,0.8}
\definecolor{azul}{rgb}{0.0,0.3,0.6}
\lstset{
    backgroundcolor=\color{lbcolor},
    tabsize=2,
    rulesepcolor=\color{azul},
    language=C++,
    morekeywords={repeat, until, procedure, then, from,
                  lexeme_d, as_lower_d, longest_d,
                  \!, \+, \*, \>\>, \-, \&, \|, \=, \%,
                  anychar_p, alnum_p, alpha_p, digit_p, lower_p, upper_p, space_p, ch_p, str_p, oct_p, hex_p, uint_p, int_p, real_p, eps_p, end_p,
                  symbols, add,
                  end},
    basicstyle=\tiny,
    aboveskip={1\baselineskip},
%     columns=[c]fixed,
    columns=fullflexible,
    showstringspaces=false,
    extendedchars=true,
    breaklines=true,
    prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
    frame=single,
    showtabs=false,
    showspaces=false,
    showstringspaces=false,
    identifierstyle=\ttfamily,
    keywordstyle=\color[rgb]{0.1,0.1,0.6}\bfseries,
    commentstyle=\color[rgb]{0.133,0.545,0.133},
    stringstyle=\color[rgb]{0.627,0.126,0.941},
    keepspaces=true,
    escapeinside=``,
    numbersep=5pt,
    numberstyle=\tiny
}

\definecolor{linkcol}{rgb}{0,0,0.4} 
\definecolor{citecol}{rgb}{0.5,0,0} 

\hypersetup
{
bookmarksopen=true,
pdftitle="Art\'iculo CACIC: magGen",
pdfauthor="Arroyo - Kilmurray - Picco", 
pdfsubject="Generador de Evaluadores est\'aticos para MAG.", %subject of the document
pdftoolbar=false, % toolbar hidden
pdfmenubar=true, %menubar shown
pdfhighlight=/O, %effect of clicking on a link
colorlinks=true, %couleurs sur les liens hypertextes
pdfpagemode=UseNone, %aucun mode de page
pdfpagelayout=SinglePage, %ouverture en simple page
pdffitwindow=true, %pages ouvertes entierement dans toute la fenetre
linkcolor=linkcol, %couleur des liens hypertextes internes
citecolor=citecol, %couleur des liens pour les citations
urlcolor=linkcol %couleur des liens pour les url
}

\lstdefinelanguage{specmag}{
  keywords={compute, end, all, semantic, domain, attributes, rules, sort, op, function, infix, prefix, postfix, syn, inh, left, right, non_assoc, and, and_eq, asm, auto, bitand, bitor, break, case, catch, class, compl, const, const_cast, continue, default, delete, do, double, dynamic_cast, else, enum, explicit, export, extern, false, for, friend, goto, if, inline, long, mutable, namespace, new, not, not_eq, operator, or, or_eq, private, protected, public, register, reinterpret_cast, return, short, signed, sizeof, static, static_cast, struct, switch, template, this, throw, true, try, typedef, typeid, typename, union, unsigned, using, virtual, void, volatile, wchar_t, while, xor, xor_eq, bool, char, float, int, string, repeat, until, procedure, then, from},
  sensitive=true,
  morecomment=[s]{/*}{*/},
  morecomment=[l]{\//},
  morestring=[d]{"}
}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\newcommand{\textbtt}[1]{\texttt{\textbf{#1}}}
\newcommand{\urllink}[1]{\htmladdnormallink{#1}{#1}}
\newcommand{\maggen}{\textbf{magGen}}
\newcommand{\boost}{\textit{\textbf{Boost}}}
\newcommand{\spirit}{\textit{\textbf{Spirit}}}

\usepackage{url}
\newcommand{\keywords}[1]{\par\addvspace\baselineskip \noindent\keywordname\enspace\ignorespaces#1}

\begin{document}

% \mainmatter  % start of an individual contribution

% first the title is needed
\title{magGen: Un Generador de Evaluadores de Gramáticas de Atributos Multiplanes}

% a short form should be given in case it is too long for the running head
% \titlerunning{magGen: Generador de Evaluadores para MAG.}

% the name(s) of the author(s) follow(s) next
%
% NB: Chinese authors should write their first names(s) in front of
% their surnames. This ensures that the names appear correctly in
% the running heads and the author index.
%
\author{Marcelo Arroyo; Gerardo Kilmurray y Gonzalo Picco%
\footnote{ \{marroyo,gkilmurray,gpicco\}@dc.exa.unrc.edu.ar. Departamento de Computación, FCFQyN, U.N.R.C.}}

\date{}

%
% \authorrunning{Kilmurray - Picco - Arroyo}
% (feature abused for this document to repeat the title also on left hand pages)
% \email{ gkilmurray $\vert$ gpicco $\vert$ marroyo@dc.unrc.edu.ar}

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
%\institute{Departamento de Computación, FCFQyN \\ Universidad Nacional de Río Cuarto}

%
% NB: a more complex sample for affiliations and the mapping to the
% corresponding authors can be found in the file "llncs.dem"
% (search for the string "\mainmatter" where a contribution starts).
% "llncs.dem" accompanies the document class "llncs.cls".
%

% \toctitle{magGen: Generador de Evaluadores est\'aticos para MAG.}
% \tocauthor{Kilmurray - Picco - Arroyo}

\maketitle

\begin{abstract}

Las \emph{Gramática de Atributos} (GA) son un formalismo que poseen el poder descriptivo de las Gramáticas Libres de Contexto (CFG) y la expresividad de los lenguajes funcionales, para definir la semántica de un lenguaje.%34

Las ecuaciones de una GA inducen dependencias entre los atributos que ocurren en la producción. Si una GA contiene dependencias circulares no podrá ser evaluada, ya que no existirá un orden de evaluación consistente. Esto se conoce como el
\emph{Problema de Circularidad}.%40

El test de circularidad es intrínsecamente exponencial, lo que dificulta la implementación de
evaluadores eficientes, por lo que comúnmente las herramientas imponen restricciones en las 
dependencias.

En 1998, Wuu Yang caracteriza una nueva familia de GA, denominada \emph{Gramáticas de
Atributos Multiplanes} (MAG) o NC(1), que permiten una mayor expresividad, presentando un algoritmo eficiente para su evaluación.

Este trabajo describe \maggen: un generador de evaluadores estáticos para la familia MAG.
 
\end{abstract}

\section{Introducción}

Desde que Knuth introdujo, en 1966, las Gramáticas de Atributos (GA)\cite{Knuth}, éstas se han utilizado ampliamente para el desarrollo de herramientas de procesamiento de lenguajes formales, como compiladores, intérpretes, traductores, así  como también para especificar la semántica de lenguajes de programación.

Actualmente, existen muchas herramientas basadas en gramáticas de atributos
pero generalmente se basan en familias más restrictivas como las absolutamente no circulares (ANCAG) o las ordenadas definidas por Uke Kastens (OAG)\cite{tesismarcelo}. 
Estas familias se caracterizan por requerir que exista un único orden (plan) de evaluación 
por cada producción. \\

Las GA multiplan pueden tener varios planes asociados a una producción ya que las discrimina en base a sus contextos de aplicación. El plan correspondiente de una instancia de una producción en un árbol sintáctico se debe seleccionar dinámicamente en base a su contexto.

En este trabajo se describe una implementación de \maggen (\textbf{m}ultiplan 
\textbf{a}ttribute \textbf{g}rammar \textbf{gen}erator), las optimizaciones desarrolladas 
sobre las ideas propuestas por Wuu Yang\cite{wuu-yang1} y algunas medidas de desempeño del
generador y de los evaluadores generados. \\

En las primeras secciones se introducen los conceptos fundamentales sobre las gramáticas de atributos (GAs) y métodos de evaluación. En las secciones subsiguientes se describe el
desarrollo de \maggen, los detalles más relevantes de su implementación, algunas medidas de
rendimiento obtenidas y finalmente las conclusiones y trabajo futuro.

\section{Gramáticas de atributos}

En una gramática de atributos, se relaciona con cada símbolo de una gramática libre de contexto con un conjunto de atributos y con cada poducción un conjunto \textit{de reglas semánticas} o \emph{ecuaciones}, las cuales definen valores de los atributos en el contexto 
de la producción.

Una GA permite definir la sintaxis y semántica de un lenguaje de una manera declarativa y
se usan ampliamente para el desarrollo de procesadores de lenguajes, como compiladores, 
intérpretes y herramientas de análisis de código.

\begin{definition}
Una gramática libre de contexto es una tupla \mbox{$CFG=<V,T,S,P>$} donde $V$ es el conjunto de no terminales, $T$ el conjunto de terminales, $\Sigma = V \cup T$, es el conjunto de símbolos, $S \in V$ es el símbolo inicial y $P$ es el conjunto de producciones de la forma
$(X_0, X_1, \ldots, X_k)$, donde $X_0 \in V$ se denomina la parte izquierda (left hand side,
lhs) y $X_1, \ldots, X_k$ ($X_i, 1 \leq i \leq k$) es la parte derecha (rhs). Las produciones se denotan comúnmente de la forma $X_0 \rightarrow X_1, \ldots, X_k$
\end{definition}

\begin{definition}
\label{def:arbolderivacion}
Dada una gramática $G = <V,T,S,P>$, se define $ST=(K,D)$ como un \emph{árbol de derivación}, 
o Parse Tree, donde $K$ es un conjunto de nodos y $D$ es una relación no reflexiva sobre $K$, 
si y sólo si cumple las siguientes condiciones:

\begin{itemize}
\item $ K \subseteq (V \cup T \cup \lambda) $
\item $k_{0} = S$
\item $k_i \in K$ y $(k_0,k_i) \in D$, si $S \rightarrow k_{1} \ldots k_{n} \in P$
\item Si un nodo $k \in T \cup \{\lambda\}$, entonces $k$ es una \textbf{hoja} de $ST$
\item Si $k_{i} \in V$,  ($1 \leq i \leq n$), entonces $k_{i}$ es la raíz del 
      sub-árbol sintáctico para la CFG $<V_{i},T_{i},k_I,P_{i}>$, donde $V_i$, $T_i$ y $P_i$
      son los símbolos terminales, no-terminales y producciones alcanzables desde las 
      producciones $p$ cuyo $lhs(p) = k_i$.
      En este caso, $k_i$ se denomina \textbf{nodo interior}.
\end{itemize}
\end{definition}

\begin{definition}
\label{def:grammarattr}
Una gramática de atributos es una tupla \mbox{$GA=<G,A,V,Dom,F,R>$} donde:
\begin{itemize}
\item $G=<V_N,V_T,S,P>$ es una CFG reducida y no ambigua.
\item $A = \bigcup_{X \in \Sigma} A(X)$, es el conjunto finito de atributos ($A(X)$ es el conjunto de atributos asociados al símbolo $X$).

$A=S \cup H$, $S \cap H = \emptyset$. $S$ es el conjunto de atributos \textbf{sintetizados} y
$H$ es el conjunto de atributos \textbf{heredados}%
\footnote{Intituivamente, los atributos heredados transmiten valores en forma descendente
en un árbol atribuido, mientras que los sintetizados lo hacen en forma ascendente.}.
\item $V$ es el conjunto finito de dominios de valores de los atributos.
\item $Dom:A \rightarrow V$ asocia a cada atributo un dominio o conjunto de valores $d \in V$.
\item $F$ es un conjunto finito de funciones semánticas de la forma:
\begin{equation}
f \subseteq (\bigotimes\limits_{j=0}^{k}{ Dom(a_{j} ))\rightarrow Dom(a_{0})}
\end{equation}
 
\item $R = \bigcup _{p \in P} R^{p}$ es el conjunto finito de reglas de atribución o ecuaciones asociadas a cada producción p de P, donde
\begin{equation}
R^{p} = \bigcup\limits_{j=0}^{m^{p}}{\{r_{j}^{p}\}}
\end{equation}
y cada regla $r_{j}^{p} \in R^{p}$, con 0 $\leq$ j $\leq$ $m^{p}$ es de la forma:

\begin{equation}
\label{eq:equation}
r_{j}^{p}: X_{0}.a_{0} = f(X_{1}.a_{1} ,\dots , X_{k}.a_{k})
\end{equation} 
donde cada $X_i$ es un símbolo que ocurre en la producción \textit{p} , $a_i \in A(X_i)$, 
($0 \leqslant i \leqslant k$) y $f \in F$.

En una ecuación como \texttt{(\ref{eq:equation})}, $X_{i}.a_{i} \rightarrow X_{0}.a_{0}$, es decir, $X_0.a_0$ \textbf{depende} de $X_{i}.a_{i}$ ($1 \leq i \leq k$).
\end{itemize}
\end{definition}

Se utilizará la notación $X.a$ para denotar que $a \in A(X)$.

\begin{definition}
Una GA es \textbf{bien definida} si cada producción $p:X_0 \rightarrow X_1 \ldots X_k$, $R^p$ 
contiene ecuaciones que definen los atributos $a \in S(X_0)$ y todos los atributos 
$b \in H(X_i)$, ($i > 0$).
\end{definition}

\begin{definition}
Un árbol sintáctico en el cual a cada nodo se ha extendido para incluir los valores de los
atributos del símbolo correspondiente, se denomina \textbf{árbol atribuído}.
\end{definition}

\begin{definition} 
\label{def:ast-attr}
El árbol atribuido, sobre el cual los valores de los atributos en cada nodo ya se han definido mediante un proceso de evaluación, se denomina \textbf{árbol decorado}.
\end{definition}

\begin{definition} El grafo de dependencias directas de una producción $p$,

$DP(p) = \{(X_{i}.a,X_{j}.b) \mid X_{j}.b \rightarrow X_{i}.a \:
(X_{i}.a \: \emph{depende} \: de \: X_{j}.b) \: en \: R^{p}\} $ 
\end{definition}

\begin{definition} Para un árbol sintáctico $T(GA)$, su grafo de dependencias 
$GD(T)$ es el grafo construido a partir de la composición de los grafos de dependencias 
$GD(p)$ de cada instancia de producción en $T$.
\end{definition}

\subsection{Evaluación de gramáticas de atributos}
\label{sec:eval}

Cualquier evaluador de GAs deberá respetar el orden de evaluación de los atributos impuesto
por las dependencias.

\begin{definition}
Una secuencia (o plan) de evaluación de atributos es consistente con las dependencias de los atributos de la GA si y sólo si para cada ecuación $r_{j}^{p} : X_{0}.a = f(\ldots, X_{i}.b, \ldots)$ 
en una producción $p \in P$, la definición de $X_{i}.b{i}$ deberá preceder a $X_{0}.a$.
\end{definition}

\begin{definition}
Una gramática de atributos $GA$ es ``\textbf{circular}'' si y sólo si existe un árbol sintáctico atribuido $T(GA)$, tal que su grafo de dependencias $GD(T)$ contiene al menos un ciclo.
\end{definition}

Si una GA contiene dependencias circulares no será posible encontrar un orden de evaluación consistente. Esto se conoce como el ``\textit{problema de la circularidad}'', el cual se ha demostrado ser intrínsecamente exponencial\cite{intri-exc}. El propósito de muchas investigaciones, ha sido descubrir nuevas familias o subgrupos de GAs, para las cuales puedan detectarse circularidades con algoritmos de menor complejidad. \\

En 1998, Wuu Yang en \cite{wuu-yang2} caracteriza una nueva jerarquía de la GAs, denominadas \textbf{NC(n)}\footnote{Non Circular AG basadas en Lookahead behaviour.}.

\maggen soporta la familia MAG NC(1), la cual contiene a la familia de las OAG presentadas 
por Uwe Kastens\cite{kastens} en 1980, presentando un algoritmo de evaluación basado en secuencias de visita.
El algoritmo es exponencial en el numero de símbolos y producciones, lo cual lo hace un problema perfectamente tratable.

%\subsection{Evaluación estática}
%\label{subsec:eval-est}

Los métodos de evaluación estáticos deben tener en cuenta todos los árboles sintácticos posibles a ser generados por la gramática y calcular las dependencias entre las instancias de los atributos, para cada uno de ellos. Esta información, calculada en tiempo de generación del
evaluador, permite que la evaluación sea muy eficiente ya que no es necesario detectar
circularidades ni generar los órdenes de evaluación en tiempo de ejecución. \\

Un árbol sintáctico se construye a partir de la aplicación sucesiva de producciones de la gramática. Una instancia de una producción en un árbol sintáctico tiene como \emph{contexto inferior} a las instancias de las producciones aplicadas a los símbolos no terminales de su parte derecha y, como \emph{contexto superior} a la instancia de la producción a partir del
cual se ha construido dicho árbol.

Dada una producción $p$ se deben considerar tres tipos de dependencias que definen el contexto de la misma: Las directas, obtenidas por las ecuaciones de $p$ y las de los contextos superior e inferiores.

Instancias diferentes de una producción $p$ tendrán las mismas dependencias directas, pero podrán tener diferentes dependencias impuestas por el contexto. Es necesario entonces, determinar todas las \emph{dependencias posibles} entre los atributos que ocurren en una producción para luego poder determinar todos los posibles \emph{planes o secuencias de evaluación posibles} entre los atributos que ocurren en una producción. \\

Una vez determinadas las secuencias de evaluación, hay que considerar que las instancias
de atributos se evalúen en el contexto de su definición.

Para eso las secuencias se traducen a \emph{secuencias de visita}, las cuales son tres
operaciones introducidas por Uwe Kastens en \cite{kastens}:

\begin{description}
\item \emph{\textbf{visit(child,i)}} indica que el evaluador debe moverse (visitar) el nodo hijo \emph{child} de $n$ y corresponde a la \emph{i-ésima} visita al nodo hijo.

\item \emph{\textbf{compute(at)}} indica que debe evaluarse la ecuación que define $at$ en la producción $p$ aplicada correspondiente al nodo $n$.

\item \emph{\textbf{leave}} indica que deberá retornar al nodo padre, finalizando la visita corriente.
\end{description}

Aquí se presenta una leve modificación de las secuencias de visita en \cite{kastens}, principalmente en las operaciones \emph{visit} y \emph{leave}. Si el evaluador recuerda en cada
nodo del árbol atribuído el punto de la secuencia hasta donde de evaluó en la visita anterior,
se puede prescindir del parámetro en estas dos operaciones.

La evaluación termina cuando se ejecutaron todas las operaciones de la secuencia de visita del nodo raíz del árbol sintáctico.

Estos evaluadores pertenecen a una familia denominada \emph{Evaluadores Multivisita}, ya que el proceso de evaluación puede requerir múltiples visitas a un nodo.

\subsection{Gramáticas de Atributos Multiplanes}
\label{def:MAG}

Para abordar la presentación y definición de las Gramáticas de Atributos Multiplanes es necesario introducir algunos conceptos previamente.

\begin{definition}
Las dependencias transitivas entre los atributos del símbolo $X$ 
en subárboles a partir de la producción $p$ de la forma $X \rightarrow \ldots$ se denomina 
\textbf{Downward Characteristic Graph}, denotado como $DCG_X(p)$.
\end{definition}

\begin{definition}
El \textbf{conjunto de dependencias aumentadas de una producción $q$ con contexto inferior
$p_1, \ldots, p_k$}:

$$
ADP (q | p_{1}, p_{2}, \dots, p_{k}) = DP(q) \bigcup_{i=1}^k DGC_{X_i} (p_{i})
$$
tal que $q \rightarrow p_1 \ldots p_k \in P$.
\end{definition}

Cada grafo $ADP (q | p_1, p_2, \dots, p_k)$ representa las dependencias entre los atributos
de los símbolos que aparecen en un árbol que tenga como raíz una instancia del símbolo de la
parte izquierda de la producción $q \rightarrow \alpha X_1 \ldots X_k \beta$
en que se habrían aplicado las producciones $p_1: X_1 \rightarrow \psi_1$, $\ldots$,
$p_k: X_K \rightarrow \psi_k$ en su contexto (subárbol) inferior inmediato. \\

El conjunto de todas las posibles dependencias aumentadas para una producción q se define como:
$$ SADP(q) = \{ ADP (q | p_{1}, p_{2}, \dots, p_{k}) \mid \forall 
p \rightarrow p_1, \ldots, p_k \in P \} $$

A modo de ejemplo, en la GA de la figura \ref{fig:MAG_traducida}, los grafos

\begin{center}
\small
$DP(p_1) = \{(s1,i2),(s2,i3),(s3,i1),(s0,s1),(s0,s2),(s0,s3),(s0,s4)\}$

$DCG_X(p4) = \{(i1,s1)\}$, ($X.s1$ depende de $X.i1$)

$ADP(p_1 \mid p_4, p_2, p_5) = DP(p_1) \cup DCG_X(p_4) \cup DCG_Y(p_2) \cup DCG_Z(p_5)$
\normalsize
\end{center}

\begin{definition}
Una gramática de atributos \textit{G} es una \textit{gramática de atributos multiplanes} si y solo si 
$
\forall q \in P: (\forall g: \in SADP(q) : g\ es\ no\ circular) 
$
\end{definition}

Esta definición tiene en cuenta contextos inferiores (subárboles) de sólo un nivel, lo cual
caracteriza a la familia NC(1) de Wuu Yang. En \cite{wuu-yang2}, Wuu Yang extiende la idea 
para considerar hasta $m$ contextos inferiores, denominadas $NC(m)$ y hasta todos los posibles
contextos ($NC(\infty)$). Esta última familia coincide con las GA no circulares.

\section{Desarrollo de \maggen}
\vspace{-0.2cm}
El desarrollo de \maggen\ se realizó en 4 etapas:

a) definición del Lenguaje especificación de MAG, b) desarrollo del parser del lenguaje,
representación interna y chequeos, c) construcción de grafos y aplicación de algoritmos de cómputo de planes y secuencias de visita y d) generación de código del evaluador.

\subsection{El lenguaje de especificación de \maggen}
\label{sec:lenguajeMAG}
 
El lenguaje define secciones para la declaración del dominio semántico, donde se definen los
tipos y perfiles de las funciones y operadores a usar, la definición de los atributos de cada
símbolo y el bloque de definición de las producción de la gramática con sus ecuaciones correspondientes.

\begin{figure}[!ht]
\vspace{-0.5cm}
\begin{minipage}{0.45\textwidth}
  \begin{center}
\lstinputlisting[numbers=left, language=specmag]{ag_wuu_yang1.input}
  \end{center}
\end{minipage}
\hspace{0.6cm}\begin{minipage}{0.45\textwidth}
  \begin{center}
\lstinputlisting[firstnumber=21, numbers=left, language=specmag]{ag_wuu_yang2.input}
  \end{center}
\end{minipage}
\vspace{-0,5cm}
\caption{\label{fig:MAG_traducida}MAG en lenguaje de especificación de \maggen.}
\end{figure}

La figura \ref{fig:MAG_traducida} muestra un ejemplo de especificación de una GA.

\section{Detalles de implementación}
\vspace{-0.22cm}

El parser del lenguaje se apoya en la utilización de un framework reconocido mundialmente, denominado \spirit, perteneciente a la biblioteca de C++ llamada \boost\cite{boost}. Esta decisión trajo dos grandes beneficios; la confiabilidad del parser obtenido y la rápida obtención del mismo, ya que, la gran ventaja de \spirit\ es permitir escribir la definición de la gramática en
\textbf{C++} directamente sin tener que recurrir a herramientas externas. \\

La herramienta verifica que la GA de entrada esté bien definida y genera el evaluador,
los grafos de dependencias (para depuración) y los planes generados.

El chequeo de ciclicidad sobre los grafos $ADP$, se implementó utilizando el algoritmo de búsqueda en profundidad (Depth-first search) de \boost\ combinado con la creación de un ``visitador'' especializado, el cual a medida que recorre el grafo, va recordando los nodos y aristas visitadas mientras no se halla detectado un ciclo. Esos subgrafo se generan
(en forma de archivos gráficos) al usuario en caso de error, para que pueda corregirse el
error.

\subsection{Construcción de planes}
\label{subsec:const-planes}

Los planes de evaluación son órdenes parciales computados a partir del orden topológico de 
cada $ADP(q \mid p_1, \ldots, p_k)$ y a partir de un orden de evaluación requerido para los atributos del símbolo de la parte izquierda de $q$.%
\footnote{Lo que constituye una restricción en el orden de los atributos del $lhs(q)$ impuesto por el contexto superior de $q$.}

Para el ejemplo presentado en la figura \ref{fig:MAG_traducida} se deben computar 7 planes.
Cada plan es una secuencia de enteros representando números de ecuaciones. A continuación se 
muestran algunos de los planes computados.

\begin{enumerate}
\item $<6,2,9,3,5,4,10,1>$ = gen\_plan($\lambda| p_1 | <p_4,p_2,p_5>$)
\item $<7,4,8,2,9,3,10,1>$ = gen\_plan($\lambda| p_1 | <p_4,p_3,p_5>$)
\item $<7,4,8,3>$ = gen\_plan($proj(2,lhs(p_3)) | p_3 | <>$)
\item $<2,9>$ = gen\_plan($proj(1,lhs(p_4)) | p_4 | <>$)
\item \ldots
\end{enumerate}

La función gen\_plan($s | P | i$) toma las restricciones del contexto superior 
($s$), la regla ($P$) y el contexto inferior (secuencia de producciones), $i$.

La función $proj(p,s)$ proyecta un orden consistente de los atributos del símbolo $s$ (parte
izquierda de una producción), en base al plan $p$ (plan de su contexto superior).

Se puede notar que los dos primeros planes corresponden a la producción $p_1$ (cada uno
se corresponde con un diferente contexto inferior), el tercero a la producción $p_3$
en el contexto del plan 2 y el cuarto a la producción $p_4$ en el contexto del plan 1.

\subsection{Construcción Secuencias de Visita}
\label{seubsec:seq-visit}
\vspace{-0.22cm}

Cada plan se transforma en una secuencia de visitas, es decir una secuencia de operaciones
\emph{eval(eq)}, \emph{visit(child)} y \emph{leave}.

El algoritmo de generación de secuencias de visita es simple y lineal a partir de cada producción, un plan y los tipos (heredados o sintetizados) de los atributos de los símbolos
que ocurren en la producción.

Para cada elemento $i$ del plan:
\begin{itemize}
\item si la ecuación $i$ define un atributo sintetizado del símbolo de la parte izquierda o un
atributo heredado de un símbolo de la parte derecha de la producción, 
generar un $compute(i)$,
\item si la ecuación $i$ define un atributo heredado del símbolo de la parte izquierda de la
producción, generar un $leave$,
\item si la ecuación $i$ define un atributo sintetizado del símbolo de la parte derecha de 
la producción, generar un $visit(j)$, donde $j$ es el índice del nodo hijo correspondiente.
\end{itemize}

A modo de ejemplo, se muestra una secuencia de visita generada por \maggen para el ejemplo 
de la figura \ref{fig:MAG_traducida}:

el plan $<7,4,8,3>$ se traduce en $<compute(7),leave,compute(8),leave>$, lo que hará que el 
evaluador realice la evaluación de la ecuación 7, luego retorne al nodo padre, ejecutará las
secuencias de visita correspondientes para luego visitar nuevamente al primer nodo, computará
la ecuación 8 y finalmente retornará al nodo padre. Se debe notar que antes de evaluar la ecuación 8 se require computar el valor de $Y.i3$, el cual se hará en el contexto superior. \\

El evaluador de atributos lanza la ejecución de las secuencias de visita asociados a la producción de comienzo, lo que demandará la evaluación de todos los atributos del árbol.

\subsection{Generación de código}
\vspace{-0.22cm}

La etapa final de \maggen\ esta dada por la generación de código del evaluador. 
Toda la lógica (plan seleccionado, ecuaciones) e información (atributos) del evaluador está codificada en la clase \emph{Node}, el cual representa un nodo (polimórfico) de un árbol atribuído.

Su declaración e implementación está en los archivos \texttt{node.hpp} y \texttt{node.cpp}.
Los planes se representan en la clase \emph{plan} (plan.\{hpp,cpp\}).

\subsection{Algoritmo de evaluación}
\label{sec:codcppalgeval}

El evaluador de un AST se basa en dos etapas:

\begin{enumerate}

\item \textbtt{traverse}: selección del plan de evaluación para cada nodo del árbol en base
a la instancia de la producción correspondiente al nodo y su contexto (superior e inferior). Este primer recorrido del árbol es descendente.

\item \textbtt{evaluate}: es el intérprete de las secuencias de visitas. Inicia ejecutando
la secuencia de visitas de la raíz, la cual conducirá las visitas y ejecución de las ecuaciones en el árbol.

\end{enumerate}



\section{Desempeño}

En la etapa de prueba de \maggen\ se han analizado una serie de medidas performance que permitieron observar números concretos sobre el funcionamiento de la herramienta. En la figura \ref{fig:version_boot} se muestran los tiempos en la compilación de la herramienta, teniendo en cuenta dos versiones de Spirit Boost\footnote{Se uso la mínima versión compatible (Boost 1.37) y la actual versión (Boost 1.43).}. Se detecta un incremento de performance con el uso de la Spirit Boost actual.

\begin{figure}[!hbtp]
\vspace{-0.5cm}
\begin{minipage}{0.47\textwidth}
\begin{center} 
\begin{lstlisting}[columns=fullflexible, backgroundcolor=\color{white}]
M ::= E
    M.valor = E.valor
E ::= E '+' E
		E.valor = E.valor + E.valor 
    | E '-' E
        E.valor = E.valor - E.valor 
    | E '*' E
        E.valor = E.valor * E.valor 
    | E '/' E
        E.valor = E.valor / E.valor 
    | '(' E ')'
        E.valor = E.valor 
    | '-'E
        E.valor = E.valor * (-1.0)
    | num
        E.valor = num.valor
num ::= digit num
            num.valor = (digit.valor * 10.0) + num.valor
	  | real
            num.valor = real.valor
      | digit
            num.valor = digit.valor
\end{lstlisting} 
\end{center}
\end{minipage}
\hspace{0.28cm}\begin{minipage}{0.49\textwidth}
\begin{center}
\begin{lstlisting}[columns=fullflexible, backgroundcolor=\color{white}]
digit ::= '1'
            digit.valor = 1.0
        | '2'
            digit.valor = 2.0
        | '3'
            digit.valor = 3.0
        | '4'
            digit.valor = 4.0
        | '5'
            digit.valor = 5.0
        | '6'
            digit.valor = 6.0
        | '7'
            digit.valor = 7.0
        | '8'
            digit.valor = 8.0
        | '9'
            digit.valor = 9.0
        | '0'
            digit.valor = 0.0
real ::= digit '.' digit
            real.valor = digit.valor + (digit.valor / 10.0)
\end{lstlisting} 
\end{center}
\end{minipage}
\vspace{-0,5cm}
\caption{\label{fig:eje_expresion} GA de Expresiones.}
\end{figure}

En las figuras \ref{fug:med_eval_gen} se presentan medidas sobre los tiempos y tamaños logrados en el binario obtenido del evaluador generado por \maggen. 

\begin{figure}[!hbtp]
\small
    \begin{center}
        \setlength{\doublerulesep}{0mm}
        \setlength{\arrayrulewidth}{0.9pt}
        \begin{tabular}{|l||c|c|}
            \hline
            \rowcolor{gris} Input / Spirit           & \textbf{1.8.X}   & \textbf{2.3}   \\ \hline
            \rowcolor{white}\textbtt{MAG Wuu Yang}   & $\sim$0.087 sec & $\sim$0.084 sec \\ \hline
            \rowcolor{white}\textbtt{MAG Aritmetica} & $\sim$0.590 sec & $\sim$0.450 sec \\ \hline
        \end{tabular}
    \end{center}
    \vspace{-0,5cm}
    \caption{\label{fig:version_boot}Medidas de performance: Versión de Spirit Boost}
\normalsize
\end{figure}

\begin{figure}[!hbtp]
\begin{center}
\small
    \subfigure[Tiempos de compilación]{
        \setlength{\doublerulesep}{0mm}
        \setlength{\arrayrulewidth}{0.9pt}
        \begin{tabular}{|l||c|c|}
            \hline
            \rowcolor{gris} Input / g++          & \textbf{tiempo} \\ 
            \hline
            \rowcolor{white}\textbtt{Wuu Yang}   & 1.51 s \\ 
            \hline
            \rowcolor{white}\textbtt{Aritmetica} & 1,56 m \\ 
            \hline
        \end{tabular}
    }\subfigure[Tamaños del ejecutable]{
        \setlength{\doublerulesep}{0mm}
        \setlength{\arrayrulewidth}{0.9pt}      
        \begin{tabular}{|l||c|c|}
            \hline
            \rowcolor{gris} Input / g++          & \textbf{Kb} \\ 
            \hline
            \rowcolor{white}\textbtt{Wuu Yang}   & 48          \\ 
            \hline
            \rowcolor{white}\textbtt{Aritmetica} & 384         \\ 
            \hline
        \end{tabular}
    }
    \caption{\label{fug:med_eval_gen}Medidas para el evaluador generado}
\normalsize
\end{center}
\end{figure}

Estos resultados se desprenden de los ejemplos de las figuras \ref{fig:MAG_traducida} 
y \ref{fig:eje_expresion}.

Las pruebas realizadas también muestran que, en la práctica, a pesar que una producción
pueda aparecer en varios diferentes contextos en un árbol, los planes de evaluación de
diferentes contextos coinciden, por lo cual no se espera que una producción tenga asociado
un gran número de planes.

Por ejemplo, para el ejemplo de la figura \ref{fig:eje_expresion} se tienen en cuenta 371 contextos posibles mientras que se generan sólo 22 secuencias de visita, lo que muestra que
los evaluadores generados en la práctica serán pequeños y eficientes.

\section{Conclusiones y trabajo futuro}

Se logró obtener una herramienta modularizada, eficiente y completamente desarrollada en C++,
lo cual muestra que es posible implementar evaluadores estáticos compactos, legibles con un muy buen rendimiento para familias menos restrictivas de GAs
que las usadas comúnmente en otras herramientas.

Se está trabajando en extensiones como:
\begin{itemize}
\item Desarrollo de bibliotecas de funciones de utilidad de uso común en especificaciones, 
como manejo de ambientes, algoritmos de análisis estático (interpretación abstracta) y
generación de código.
\item Extensión de especificaciones, al estilo de las GA orientadas a objetos con mecanismos
como redefinición o delegación (forwarding) de reglas para permitir un lenguaje de 
especificación más modular.
\item Introducción de sentencias de acceso no local de atributos para simplificar las
especificaciones.
\end{itemize}

\maggen\ se encuentra disponible en
\urllink{http://genevalmag.googlecode.com/}

%\bibliographystyle{unsrt}
\begin{thebibliography}{10}

\bibitem {wuu-yang1} Wuu Yang. 1998. \textit{Multi-Plan Attribute Grammars}. Department of Computer Information Science. National Chiao-Tung University, Hsin-Chu, Taiwan.

\bibitem {wuu-yang2} Wuu Yang. 1999. \textit{A Classification of Non Circular Attribute Grammars based on Lookahead behavior}. Department of Computer and Information Science. National Chiao-Tung University, Hsin-Chu, Taiwan.

% \bibitem {wuu-yang3} Wuu Yang. 1998. \textit{Conditional Evaluation in Simple Multi-Visit Attribute Grammar Evaluators}. Department of Computer and Information Science. National
% Chiao-Tung University, Hsin-Chu, Taiwan.

\bibitem{wuu-yang4} Wuu Yang, W. C. Cheng. \emph{A Polynomial Time Extension to Ordered Attribute Grammars}. Department of Computer and Information Science.National Chiao-Tung University, Hsin-Chu, Taiwan.

\bibitem {gramatica} John E. Hopcroft, Rajeev Montwani, Jefrey D. Ullman.\textit{Introduction to Automata theory, languajes, and computation}. Addison-Wesley (2001) second edition.

\bibitem {compiladores} Alfred V. Aho, Ravi Sethi, Jeffrey D. ullman.\textit{Compilers: Principles, Techniques and Tools}. Addison-Wesley (1985)  Iberoamericana, S.A. Wilmington, Delaware, E.U.A.

\bibitem {tesismarcelo} Arroyo, Marcelo Daniel. \textit{Gramáticas de atributos, clasificación y aportes en técnicas de evaluación}. Tesis de carrera de Magister en Ciencias de la Computación. Universidad Nacional del Sur. Bahía Blanca - Argentina. 2008.

\bibitem {kastens} U. Kastens. 1980. \textit{Ordered Attribute Grammars}. Acta Informatica. Vol. 13, pp. 229-256.

\bibitem{intri-exc} Jazayeri, Ogden and Rounds. 1975. \emph{The intrinsically exponential complexity of the circularity problem for attribute grammars}. Comm. ACM 18. December 2, Pag: 697-706.

%\bibitem {meyer} Bertrand, Meyer (1997). \textit{Object-Oriented Software Construction}. Segunda edición. Prentice Hall Professional Technical Reference. Santa Barbara (California).

%\bibitem {estruc-algorit} Alfred V. Aho, John E. Hopcroft, Jefrey D. Ullman. \textit{Data Structures and Algorithms}. Addison-Wesley publishing Company, Reading, Massachusetts, E. U. A.(1983).

%\bibitem {valen} Valentin David. \textit{Attribute Grammars for C++ Disambiguation}. LRDE, 2004.

\bibitem {Knuth} D. Knuth. 1968. \textit{Semantics of context free languages}. Math Systems Theory 2.June 2.Pag: 127-145.

 
%\bibitem {eclipse} \textbf{eclipse}. \textit{Multi-language software development environment.} URL:\urllink{http://www.eclipse.org/}.
% 
%\bibitem {doxy} \textbf{doxygen}. \textit{A documentation generator for C++, C, Java, Objective-C, Python, IDL (CORBA and Microsoft flavors), Fortran, VHDL, PHP and C\#}. URL: \urllink{www.doxygen.org}.

%\bibitem{c++1} \textbf{C++}. \textit{C++ Annotations Version 8.2.0.} URL: \urllink{http://www.icce.rug.nl/documents/cplusplus/}. 

%\bibitem{c++2} \textbf{C++}. \textit{C++ reference} URL: \urllink{http://www.cppreference.com/wiki/es/start}. 

%\bibitem{latex} \textbf{\LaTeX}. \textit{A document preparation system} URL: \urllink{http://www.latex-project.org/}.

\bibitem{boost} \emph{Boost C++ Libraries}. URL: \urllink{http://www.boost.org/} 
 
\end{thebibliography}

\end{document}

